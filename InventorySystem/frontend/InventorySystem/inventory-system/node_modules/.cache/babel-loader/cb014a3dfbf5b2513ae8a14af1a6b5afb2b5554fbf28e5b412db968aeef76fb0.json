{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport { reactive } from 'vue';\nimport { isNil } from 'lodash-unified';\nimport { markNodeData, NODE_KEY } from './util.mjs';\nimport { hasOwn, isArray, isFunction, isString } from '@vue/shared';\nimport { isBoolean, isUndefined } from '../../../../utils/types.mjs';\nconst getChildState = node => {\n  let all = true;\n  let none = true;\n  let allWithoutDisable = true;\n  for (let i = 0, j = node.length; i < j; i++) {\n    const n = node[i];\n    if (n.checked !== true || n.indeterminate) {\n      all = false;\n      if (!n.disabled) {\n        allWithoutDisable = false;\n      }\n    }\n    if (n.checked !== false || n.indeterminate) {\n      none = false;\n    }\n  }\n  return {\n    all,\n    none,\n    allWithoutDisable,\n    half: !all && !none\n  };\n};\nconst reInitChecked = function (node) {\n  if (node.childNodes.length === 0 || node.loading) return;\n  const {\n    all,\n    none,\n    half\n  } = getChildState(node.childNodes);\n  if (all) {\n    node.checked = true;\n    node.indeterminate = false;\n  } else if (half) {\n    node.checked = false;\n    node.indeterminate = true;\n  } else if (none) {\n    node.checked = false;\n    node.indeterminate = false;\n  }\n  const parent = node.parent;\n  if (!parent || parent.level === 0) return;\n  if (!node.store.checkStrictly) {\n    reInitChecked(parent);\n  }\n};\nconst getPropertyFromData = function (node, prop) {\n  const props = node.store.props;\n  const data = node.data || {};\n  const config = props[prop];\n  if (isFunction(config)) {\n    return config(data, node);\n  } else if (isString(config)) {\n    return data[config];\n  } else if (isUndefined(config)) {\n    const dataProp = data[prop];\n    return isUndefined(dataProp) ? \"\" : dataProp;\n  }\n};\nconst setCanFocus = function (childNodes, focus) {\n  childNodes.forEach(item => {\n    item.canFocus = focus;\n    setCanFocus(item.childNodes, focus);\n  });\n};\nlet nodeIdSeed = 0;\nclass Node {\n  constructor(options) {\n    this.isLeafByUser = void 0;\n    this.isLeaf = void 0;\n    this.id = nodeIdSeed++;\n    this.text = null;\n    this.checked = false;\n    this.indeterminate = false;\n    this.data = null;\n    this.expanded = false;\n    this.parent = null;\n    this.visible = true;\n    this.isCurrent = false;\n    this.canFocus = false;\n    for (const name in options) {\n      if (hasOwn(options, name)) {\n        this[name] = options[name];\n      }\n    }\n    this.level = 0;\n    this.loaded = false;\n    this.childNodes = [];\n    this.loading = false;\n    if (this.parent) {\n      this.level = this.parent.level + 1;\n    }\n  }\n  initialize() {\n    var _a;\n    const store = this.store;\n    if (!store) {\n      throw new Error(\"[Node]store is required!\");\n    }\n    store.registerNode(this);\n    const props = store.props;\n    if (props && typeof props.isLeaf !== \"undefined\") {\n      const isLeaf = getPropertyFromData(this, \"isLeaf\");\n      if (isBoolean(isLeaf)) {\n        this.isLeafByUser = isLeaf;\n      }\n    }\n    if (store.lazy !== true && this.data) {\n      this.setData(this.data);\n      if (store.defaultExpandAll) {\n        this.expanded = true;\n        this.canFocus = true;\n      }\n    } else if (this.level > 0 && store.lazy && store.defaultExpandAll && !this.isLeafByUser) {\n      this.expand();\n    }\n    if (!isArray(this.data)) {\n      markNodeData(this, this.data);\n    }\n    if (!this.data) return;\n    const defaultExpandedKeys = store.defaultExpandedKeys;\n    const key = store.key;\n    if (key && !isNil(this.key) && defaultExpandedKeys && defaultExpandedKeys.includes(this.key)) {\n      this.expand(null, store.autoExpandParent);\n    }\n    if (key && store.currentNodeKey !== void 0 && this.key === store.currentNodeKey) {\n      store.currentNode = this;\n      store.currentNode.isCurrent = true;\n    }\n    if (store.lazy) {\n      store._initDefaultCheckedNode(this);\n    }\n    this.updateLeafState();\n    if (this.level === 1 || ((_a = this.parent) == null ? void 0 : _a.expanded) === true) this.canFocus = true;\n  }\n  setData(data) {\n    if (!isArray(data)) {\n      markNodeData(this, data);\n    }\n    this.data = data;\n    this.childNodes = [];\n    let children;\n    if (this.level === 0 && isArray(this.data)) {\n      children = this.data;\n    } else {\n      children = getPropertyFromData(this, \"children\") || [];\n    }\n    for (let i = 0, j = children.length; i < j; i++) {\n      this.insertChild({\n        data: children[i]\n      });\n    }\n  }\n  get label() {\n    return getPropertyFromData(this, \"label\");\n  }\n  get key() {\n    const nodeKey = this.store.key;\n    if (this.data) return this.data[nodeKey];\n    return null;\n  }\n  get disabled() {\n    return getPropertyFromData(this, \"disabled\");\n  }\n  get nextSibling() {\n    const parent = this.parent;\n    if (parent) {\n      const index = parent.childNodes.indexOf(this);\n      if (index > -1) {\n        return parent.childNodes[index + 1];\n      }\n    }\n    return null;\n  }\n  get previousSibling() {\n    const parent = this.parent;\n    if (parent) {\n      const index = parent.childNodes.indexOf(this);\n      if (index > -1) {\n        return index > 0 ? parent.childNodes[index - 1] : null;\n      }\n    }\n    return null;\n  }\n  contains(target, deep = true) {\n    return (this.childNodes || []).some(child => child === target || deep && child.contains(target));\n  }\n  remove() {\n    const parent = this.parent;\n    if (parent) {\n      parent.removeChild(this);\n    }\n  }\n  insertChild(child, index, batch) {\n    if (!child) throw new Error(\"InsertChild error: child is required.\");\n    if (!(child instanceof Node)) {\n      if (!batch) {\n        const children = this.getChildren(true);\n        if (!(children == null ? void 0 : children.includes(child.data))) {\n          if (isUndefined(index) || index < 0) {\n            children == null ? void 0 : children.push(child.data);\n          } else {\n            children == null ? void 0 : children.splice(index, 0, child.data);\n          }\n        }\n      }\n      Object.assign(child, {\n        parent: this,\n        store: this.store\n      });\n      child = reactive(new Node(child));\n      if (child instanceof Node) {\n        child.initialize();\n      }\n    }\n    child.level = this.level + 1;\n    if (isUndefined(index) || index < 0) {\n      this.childNodes.push(child);\n    } else {\n      this.childNodes.splice(index, 0, child);\n    }\n    this.updateLeafState();\n  }\n  insertBefore(child, ref) {\n    let index;\n    if (ref) {\n      index = this.childNodes.indexOf(ref);\n    }\n    this.insertChild(child, index);\n  }\n  insertAfter(child, ref) {\n    let index;\n    if (ref) {\n      index = this.childNodes.indexOf(ref);\n      if (index !== -1) index += 1;\n    }\n    this.insertChild(child, index);\n  }\n  removeChild(child) {\n    const children = this.getChildren() || [];\n    const dataIndex = children.indexOf(child.data);\n    if (dataIndex > -1) {\n      children.splice(dataIndex, 1);\n    }\n    const index = this.childNodes.indexOf(child);\n    if (index > -1) {\n      this.store && this.store.deregisterNode(child);\n      child.parent = null;\n      this.childNodes.splice(index, 1);\n    }\n    this.updateLeafState();\n  }\n  removeChildByData(data) {\n    let targetNode = null;\n    for (let i = 0; i < this.childNodes.length; i++) {\n      if (this.childNodes[i].data === data) {\n        targetNode = this.childNodes[i];\n        break;\n      }\n    }\n    if (targetNode) {\n      this.removeChild(targetNode);\n    }\n  }\n  expand(callback, expandParent) {\n    const done = () => {\n      if (expandParent) {\n        let parent = this.parent;\n        while (parent && parent.level > 0) {\n          parent.expanded = true;\n          parent = parent.parent;\n        }\n      }\n      this.expanded = true;\n      if (callback) callback();\n      setCanFocus(this.childNodes, true);\n    };\n    if (this.shouldLoadData()) {\n      this.loadData(data => {\n        if (isArray(data)) {\n          if (this.checked) {\n            this.setChecked(true, true);\n          } else if (!this.store.checkStrictly) {\n            reInitChecked(this);\n          }\n          done();\n        }\n      });\n    } else {\n      done();\n    }\n  }\n  doCreateChildren(array, defaultProps = {}) {\n    array.forEach(item => {\n      this.insertChild(Object.assign({\n        data: item\n      }, defaultProps), void 0, true);\n    });\n  }\n  collapse() {\n    this.expanded = false;\n    setCanFocus(this.childNodes, false);\n  }\n  shouldLoadData() {\n    return Boolean(this.store.lazy === true && this.store.load && !this.loaded);\n  }\n  updateLeafState() {\n    if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== \"undefined\") {\n      this.isLeaf = this.isLeafByUser;\n      return;\n    }\n    const childNodes = this.childNodes;\n    if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {\n      this.isLeaf = !childNodes || childNodes.length === 0;\n      return;\n    }\n    this.isLeaf = false;\n  }\n  setChecked(value, deep, recursion, passValue) {\n    this.indeterminate = value === \"half\";\n    this.checked = value === true;\n    if (this.store.checkStrictly) return;\n    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {\n      const {\n        all,\n        allWithoutDisable\n      } = getChildState(this.childNodes);\n      if (!this.isLeaf && !all && allWithoutDisable) {\n        this.checked = false;\n        value = false;\n      }\n      const handleDescendants = () => {\n        if (deep) {\n          const childNodes = this.childNodes;\n          for (let i = 0, j = childNodes.length; i < j; i++) {\n            const child = childNodes[i];\n            passValue = passValue || value !== false;\n            const isCheck = child.disabled ? child.checked : passValue;\n            child.setChecked(isCheck, deep, true, passValue);\n          }\n          const {\n            half,\n            all: all2\n          } = getChildState(childNodes);\n          if (!all2) {\n            this.checked = all2;\n            this.indeterminate = half;\n          }\n        }\n      };\n      if (this.shouldLoadData()) {\n        this.loadData(() => {\n          handleDescendants();\n          reInitChecked(this);\n        }, {\n          checked: value !== false\n        });\n        return;\n      } else {\n        handleDescendants();\n      }\n    }\n    const parent = this.parent;\n    if (!parent || parent.level === 0) return;\n    if (!recursion) {\n      reInitChecked(parent);\n    }\n  }\n  getChildren(forceInit = false) {\n    if (this.level === 0) return this.data;\n    const data = this.data;\n    if (!data) return null;\n    const props = this.store.props;\n    let children = \"children\";\n    if (props) {\n      children = props.children || \"children\";\n    }\n    if (isUndefined(data[children])) {\n      data[children] = null;\n    }\n    if (forceInit && !data[children]) {\n      data[children] = [];\n    }\n    return data[children];\n  }\n  updateChildren() {\n    const newData = this.getChildren() || [];\n    const oldData = this.childNodes.map(node => node.data);\n    const newDataMap = {};\n    const newNodes = [];\n    newData.forEach((item, index) => {\n      const key = item[NODE_KEY];\n      const isNodeExists = !!key && oldData.findIndex(data => (data == null ? void 0 : data[NODE_KEY]) === key) >= 0;\n      if (isNodeExists) {\n        newDataMap[key] = {\n          index,\n          data: item\n        };\n      } else {\n        newNodes.push({\n          index,\n          data: item\n        });\n      }\n    });\n    if (!this.store.lazy) {\n      oldData.forEach(item => {\n        if (!newDataMap[item == null ? void 0 : item[NODE_KEY]]) this.removeChildByData(item);\n      });\n    }\n    newNodes.forEach(({\n      index,\n      data\n    }) => {\n      this.insertChild({\n        data\n      }, index);\n    });\n    this.updateLeafState();\n  }\n  loadData(callback, defaultProps = {}) {\n    if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps).length)) {\n      this.loading = true;\n      const resolve = children => {\n        this.childNodes = [];\n        this.doCreateChildren(children, defaultProps);\n        this.loaded = true;\n        this.loading = false;\n        this.updateLeafState();\n        if (callback) {\n          callback.call(this, children);\n        }\n      };\n      const reject = () => {\n        this.loading = false;\n      };\n      this.store.load(this, resolve, reject);\n    } else {\n      if (callback) {\n        callback.call(this);\n      }\n    }\n  }\n  eachNode(callback) {\n    const arr = [this];\n    while (arr.length) {\n      const node = arr.shift();\n      arr.unshift(...node.childNodes);\n      callback(node);\n    }\n  }\n  reInitChecked() {\n    if (this.store.checkStrictly) return;\n    reInitChecked(this);\n  }\n}\nexport { Node as default, getChildState };","map":{"version":3,"names":["getChildState","node","all","none","allWithoutDisable","i","j","length","n","checked","indeterminate","disabled","half","reInitChecked","childNodes","loading","parent","level","store","checkStrictly","getPropertyFromData","prop","props","data","config","isFunction","isString","isUndefined","dataProp","setCanFocus","focus","forEach","item","canFocus","nodeIdSeed","Node","constructor","options","isLeafByUser","isLeaf","id","text","expanded","visible","isCurrent","name","hasOwn","loaded","initialize","_a","Error","registerNode","isBoolean","lazy","setData","defaultExpandAll","expand","isArray","markNodeData","defaultExpandedKeys","key","isNil","includes","autoExpandParent","currentNodeKey","currentNode","_initDefaultCheckedNode","updateLeafState","children","insertChild","label","nodeKey","nextSibling","index","indexOf","previousSibling","contains","target","deep","some","child","remove","removeChild","batch","getChildren","push","splice","Object","assign","reactive","insertBefore","ref","insertAfter","dataIndex","deregisterNode","removeChildByData","targetNode","callback","expandParent","done","shouldLoadData","loadData","setChecked","doCreateChildren","array","defaultProps","collapse","Boolean","load","value","recursion","passValue","checkDescendants","handleDescendants","isCheck","all2","forceInit","updateChildren","newData","oldData","map","newDataMap","newNodes","NODE_KEY","isNodeExists","findIndex","keys","resolve","call","reject","eachNode","arr","shift","unshift"],"sources":["../../../../../../../packages/components/tree/src/model/node.ts"],"sourcesContent":["import { reactive } from 'vue'\nimport { isNil } from 'lodash-unified'\nimport {\n  hasOwn,\n  isArray,\n  isBoolean,\n  isFunction,\n  isString,\n  isUndefined,\n} from '@element-plus/utils'\nimport { NODE_KEY, markNodeData } from './util'\n\nimport type TreeStore from './tree-store'\nimport type { Nullable } from '@element-plus/utils'\nimport type {\n  FakeNode,\n  TreeKey,\n  TreeNodeChildState,\n  TreeNodeData,\n  TreeNodeLoadedDefaultProps,\n  TreeNodeOptions,\n} from '../tree.type'\n\nexport const getChildState = (node: Node[]): TreeNodeChildState => {\n  let all = true\n  let none = true\n  let allWithoutDisable = true\n  for (let i = 0, j = node.length; i < j; i++) {\n    const n = node[i]\n    if (n.checked !== true || n.indeterminate) {\n      all = false\n      if (!n.disabled) {\n        allWithoutDisable = false\n      }\n    }\n    if (n.checked !== false || n.indeterminate) {\n      none = false\n    }\n  }\n\n  return { all, none, allWithoutDisable, half: !all && !none }\n}\n\nconst reInitChecked = function (node: Node): void {\n  if (node.childNodes.length === 0 || node.loading) return\n\n  const { all, none, half } = getChildState(node.childNodes)\n  if (all) {\n    node.checked = true\n    node.indeterminate = false\n  } else if (half) {\n    node.checked = false\n    node.indeterminate = true\n  } else if (none) {\n    node.checked = false\n    node.indeterminate = false\n  }\n\n  const parent = node.parent\n  if (!parent || parent.level === 0) return\n\n  if (!node.store.checkStrictly) {\n    reInitChecked(parent)\n  }\n}\n\nconst getPropertyFromData = function (node: Node, prop: string): any {\n  const props = node.store.props\n  const data = node.data || {}\n  const config = (props as any)[prop]\n\n  if (isFunction(config)) {\n    return config(data, node)\n  } else if (isString(config)) {\n    return data[config]\n  } else if (isUndefined(config)) {\n    const dataProp = data[prop]\n    return isUndefined(dataProp) ? '' : dataProp\n  }\n}\n\nconst setCanFocus = function (childNodes: Node[], focus: boolean): void {\n  childNodes.forEach((item) => {\n    item.canFocus = focus\n    setCanFocus(item.childNodes, focus)\n  })\n}\n\nlet nodeIdSeed = 0\n\nclass Node {\n  id: number\n  text: string | null\n  checked: boolean\n  indeterminate: boolean\n  data: TreeNodeData\n  expanded: boolean\n  parent: Node | null\n  visible: boolean\n  isCurrent: boolean\n  store!: TreeStore\n  isLeafByUser: boolean | undefined = undefined\n  isLeaf: boolean | undefined = undefined\n  canFocus: boolean\n\n  level: number\n  loaded: boolean\n  childNodes: Node[]\n  loading: boolean\n\n  constructor(options: TreeNodeOptions) {\n    this.id = nodeIdSeed++\n    this.text = null\n    this.checked = false\n    this.indeterminate = false\n    this.data = null as unknown as TreeNodeData\n    this.expanded = false\n    this.parent = null as Node | null\n    this.visible = true\n    this.isCurrent = false\n    this.canFocus = false\n\n    for (const name in options) {\n      if (hasOwn(options, name)) {\n        this[name] = options[name]\n      }\n    }\n\n    // internal\n    this.level = 0\n    this.loaded = false\n    this.childNodes = []\n    this.loading = false\n\n    if (this.parent) {\n      this.level = this.parent.level + 1\n    }\n  }\n\n  initialize() {\n    const store = this.store\n    if (!store) {\n      throw new Error('[Node]store is required!')\n    }\n    store.registerNode(this)\n\n    const props = store.props\n    if (props && typeof props.isLeaf !== 'undefined') {\n      const isLeaf = getPropertyFromData(this, 'isLeaf')\n      if (isBoolean(isLeaf)) {\n        this.isLeafByUser = isLeaf\n      }\n    }\n\n    if (store.lazy !== true && this.data) {\n      this.setData(this.data)\n\n      if (store.defaultExpandAll) {\n        this.expanded = true\n        this.canFocus = true\n      }\n    } else if (\n      this.level > 0 &&\n      store.lazy &&\n      store.defaultExpandAll &&\n      !this.isLeafByUser\n    ) {\n      this.expand()\n    }\n    if (!isArray(this.data)) {\n      markNodeData(this, this.data)\n    }\n    if (!this.data) return\n\n    const defaultExpandedKeys = store.defaultExpandedKeys\n    const key = store.key\n\n    if (\n      key &&\n      !isNil(this.key) &&\n      defaultExpandedKeys &&\n      defaultExpandedKeys.includes(this.key)\n    ) {\n      this.expand(null, store.autoExpandParent)\n    }\n\n    if (\n      key &&\n      store.currentNodeKey !== undefined &&\n      this.key === store.currentNodeKey\n    ) {\n      store.currentNode = this\n      store.currentNode.isCurrent = true\n    }\n\n    if (store.lazy) {\n      store._initDefaultCheckedNode(this)\n    }\n\n    this.updateLeafState()\n    if (this.level === 1 || this.parent?.expanded === true) this.canFocus = true\n  }\n\n  setData(data: TreeNodeData): void {\n    if (!isArray(data)) {\n      markNodeData(this, data)\n    }\n\n    this.data = data\n    this.childNodes = []\n\n    let children\n    if (this.level === 0 && isArray(this.data)) {\n      children = this.data\n    } else {\n      children = getPropertyFromData(this, 'children') || []\n    }\n\n    for (let i = 0, j = children.length; i < j; i++) {\n      this.insertChild({ data: children[i] })\n    }\n  }\n\n  get label(): string {\n    return getPropertyFromData(this, 'label')\n  }\n\n  get key(): TreeKey | null | undefined {\n    const nodeKey = this.store.key\n    if (this.data) return this.data[nodeKey]\n    return null\n  }\n\n  get disabled(): boolean {\n    return getPropertyFromData(this, 'disabled')\n  }\n\n  get nextSibling(): Nullable<Node> {\n    const parent = this.parent\n    if (parent) {\n      const index = parent.childNodes.indexOf(this)\n      if (index > -1) {\n        return parent.childNodes[index + 1]\n      }\n    }\n    return null\n  }\n\n  get previousSibling(): Nullable<Node> {\n    const parent = this.parent\n    if (parent) {\n      const index = parent.childNodes.indexOf(this)\n      if (index > -1) {\n        return index > 0 ? parent.childNodes[index - 1] : null\n      }\n    }\n    return null\n  }\n\n  contains(target: Node, deep = true): boolean {\n    return (this.childNodes || []).some(\n      (child) => child === target || (deep && child.contains(target))\n    )\n  }\n\n  remove(): void {\n    const parent = this.parent\n    if (parent) {\n      parent.removeChild(this)\n    }\n  }\n\n  insertChild(child?: FakeNode | Node, index?: number, batch?: boolean): void {\n    if (!child) throw new Error('InsertChild error: child is required.')\n\n    if (!(child instanceof Node)) {\n      if (!batch) {\n        const children = this.getChildren(true)\n        if (!children?.includes(child.data)) {\n          if (isUndefined(index) || index < 0) {\n            children?.push(child.data)\n          } else {\n            children?.splice(index, 0, child.data)\n          }\n        }\n      }\n      Object.assign(child, {\n        parent: this,\n        store: this.store,\n      })\n      child = reactive(new Node(child as TreeNodeOptions))\n      if (child instanceof Node) {\n        child.initialize()\n      }\n    }\n\n    ;(child as Node).level = this.level + 1\n\n    if (isUndefined(index) || index < 0) {\n      this.childNodes.push(child as Node)\n    } else {\n      this.childNodes.splice(index, 0, child as Node)\n    }\n\n    this.updateLeafState()\n  }\n\n  insertBefore(child: FakeNode | Node, ref: Node): void {\n    let index\n    if (ref) {\n      index = this.childNodes.indexOf(ref)\n    }\n    this.insertChild(child, index)\n  }\n\n  insertAfter(child: FakeNode | Node, ref: Node): void {\n    let index\n    if (ref) {\n      index = this.childNodes.indexOf(ref)\n      if (index !== -1) index += 1\n    }\n    this.insertChild(child, index)\n  }\n\n  removeChild(child: Node): void {\n    const children = this.getChildren() || []\n    const dataIndex = children.indexOf(child.data)\n    if (dataIndex > -1) {\n      children.splice(dataIndex, 1)\n    }\n\n    const index = this.childNodes.indexOf(child)\n\n    if (index > -1) {\n      this.store && this.store.deregisterNode(child)\n      child.parent = null\n      this.childNodes.splice(index, 1)\n    }\n\n    this.updateLeafState()\n  }\n\n  removeChildByData(data: TreeNodeData | null): void {\n    let targetNode: Node | null = null\n\n    for (let i = 0; i < this.childNodes.length; i++) {\n      if (this.childNodes[i].data === data) {\n        targetNode = this.childNodes[i]\n        break\n      }\n    }\n\n    if (targetNode) {\n      this.removeChild(targetNode)\n    }\n  }\n\n  expand(callback?: (() => void) | null, expandParent?: boolean): void {\n    const done = () => {\n      if (expandParent) {\n        let parent = this.parent\n        while (parent && parent.level > 0) {\n          parent.expanded = true\n          parent = parent.parent\n        }\n      }\n      this.expanded = true\n      if (callback) callback()\n      setCanFocus(this.childNodes, true)\n    }\n\n    if (this.shouldLoadData()) {\n      this.loadData((data) => {\n        if (isArray(data)) {\n          if (this.checked) {\n            this.setChecked(true, true)\n          } else if (!this.store.checkStrictly) {\n            reInitChecked(this)\n          }\n          done()\n        }\n      })\n    } else {\n      done()\n    }\n  }\n\n  doCreateChildren(\n    array: TreeNodeData[],\n    defaultProps: TreeNodeLoadedDefaultProps = {}\n  ): void {\n    array.forEach((item) => {\n      this.insertChild(\n        Object.assign({ data: item }, defaultProps),\n        undefined,\n        true\n      )\n    })\n  }\n\n  collapse(): void {\n    this.expanded = false\n    setCanFocus(this.childNodes, false)\n  }\n\n  shouldLoadData() {\n    return Boolean(this.store.lazy === true && this.store.load && !this.loaded)\n  }\n\n  updateLeafState(): void {\n    if (\n      this.store.lazy === true &&\n      this.loaded !== true &&\n      typeof this.isLeafByUser !== 'undefined'\n    ) {\n      this.isLeaf = this.isLeafByUser\n      return\n    }\n    const childNodes = this.childNodes\n    if (\n      !this.store.lazy ||\n      (this.store.lazy === true && this.loaded === true)\n    ) {\n      this.isLeaf = !childNodes || childNodes.length === 0\n      return\n    }\n    this.isLeaf = false\n  }\n\n  setChecked(\n    value?: boolean | string,\n    deep?: boolean,\n    recursion?: boolean,\n    passValue?: boolean\n  ) {\n    this.indeterminate = value === 'half'\n    this.checked = value === true\n\n    if (this.store.checkStrictly) return\n\n    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {\n      const { all, allWithoutDisable } = getChildState(this.childNodes)\n\n      if (!this.isLeaf && !all && allWithoutDisable) {\n        this.checked = false\n        value = false\n      }\n\n      const handleDescendants = (): void => {\n        if (deep) {\n          const childNodes = this.childNodes\n          for (let i = 0, j = childNodes.length; i < j; i++) {\n            const child = childNodes[i]\n            passValue = passValue || value !== false\n            const isCheck = child.disabled ? child.checked : passValue\n            child.setChecked(isCheck, deep, true, passValue)\n          }\n          const { half, all } = getChildState(childNodes)\n          if (!all) {\n            this.checked = all\n            this.indeterminate = half\n          }\n        }\n      }\n\n      if (this.shouldLoadData()) {\n        // Only work on lazy load data.\n        this.loadData(\n          () => {\n            handleDescendants()\n            reInitChecked(this)\n          },\n          {\n            checked: value !== false,\n          }\n        )\n        return\n      } else {\n        handleDescendants()\n      }\n    }\n\n    const parent = this.parent\n    if (!parent || parent.level === 0) return\n\n    if (!recursion) {\n      reInitChecked(parent)\n    }\n  }\n\n  getChildren(forceInit = false): TreeNodeData | TreeNodeData[] | null {\n    // this is data\n    if (this.level === 0) return this.data\n    const data = this.data\n    if (!data) return null\n\n    const props = this.store.props\n    let children = 'children'\n    if (props) {\n      children = props.children || 'children'\n    }\n\n    if (isUndefined(data[children])) {\n      data[children] = null\n    }\n\n    if (forceInit && !data[children]) {\n      data[children] = []\n    }\n\n    return data[children]\n  }\n\n  updateChildren(): void {\n    const newData = (this.getChildren() || []) as TreeNodeData[]\n    const oldData = this.childNodes.map((node) => node.data)\n\n    const newDataMap: Record<TreeKey, TreeNodeData> = {}\n    const newNodes: TreeNodeData[] = []\n\n    newData.forEach((item, index) => {\n      const key = item[NODE_KEY]\n      const isNodeExists =\n        !!key && oldData.findIndex((data) => data?.[NODE_KEY] === key) >= 0\n      if (isNodeExists) {\n        newDataMap[key] = { index, data: item }\n      } else {\n        newNodes.push({ index, data: item })\n      }\n    })\n\n    if (!this.store.lazy) {\n      oldData.forEach((item) => {\n        if (!newDataMap[item?.[NODE_KEY]]) this.removeChildByData(item)\n      })\n    }\n\n    newNodes.forEach(({ index, data }) => {\n      this.insertChild({ data }, index)\n    })\n\n    this.updateLeafState()\n  }\n\n  loadData(\n    callback: (data?: TreeNodeData[]) => void,\n    defaultProps: TreeNodeLoadedDefaultProps = {}\n  ) {\n    if (\n      this.store.lazy === true &&\n      this.store.load &&\n      !this.loaded &&\n      (!this.loading || Object.keys(defaultProps).length)\n    ) {\n      this.loading = true\n\n      const resolve = (children: TreeNodeData[]) => {\n        this.childNodes = []\n\n        this.doCreateChildren(children, defaultProps)\n        this.loaded = true\n        this.loading = false\n\n        this.updateLeafState()\n        if (callback) {\n          callback.call(this, children)\n        }\n      }\n      const reject = () => {\n        this.loading = false\n      }\n\n      this.store.load(this, resolve, reject)\n    } else {\n      if (callback) {\n        callback.call(this)\n      }\n    }\n  }\n\n  eachNode(callback: (node: Node) => void) {\n    const arr: Node[] = [this]\n    while (arr.length) {\n      const node = arr.shift()!\n      arr.unshift(...node.childNodes)\n      callback(node)\n    }\n  }\n\n  reInitChecked() {\n    if (this.store.checkStrictly) return\n    reInitChecked(this)\n  }\n}\n\nexport default Node\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}