{"ast":null,"code":"import { defineComponent, ref, computed, watch, nextTick, provide, reactive, onActivated, onMounted, onUpdated, openBlock, createElementBlock, normalizeClass, unref, createElementVNode, normalizeStyle, createBlock, resolveDynamicComponent, withCtx, renderSlot, createCommentVNode } from 'vue';\nimport { useResizeObserver, useEventListener } from '@vueuse/core';\nimport Bar from './bar2.mjs';\nimport { scrollbarContextKey } from './constants.mjs';\nimport { scrollbarProps, scrollbarEmits } from './scrollbar.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { addUnit } from '../../../utils/dom/style.mjs';\nimport { isObject } from '@vue/shared';\nimport { isNumber } from '../../../utils/types.mjs';\nconst COMPONENT_NAME = \"ElScrollbar\";\nconst __default__ = defineComponent({\n  name: COMPONENT_NAME\n});\nconst _sfc_main = /* @__PURE__ */defineComponent({\n  ...__default__,\n  props: scrollbarProps,\n  emits: scrollbarEmits,\n  setup(__props, {\n    expose,\n    emit\n  }) {\n    const props = __props;\n    const ns = useNamespace(\"scrollbar\");\n    let stopResizeObserver = void 0;\n    let stopWrapResizeObserver = void 0;\n    let stopResizeListener = void 0;\n    let wrapScrollTop = 0;\n    let wrapScrollLeft = 0;\n    let direction = \"\";\n    const distanceScrollState = {\n      bottom: false,\n      top: false,\n      right: false,\n      left: false\n    };\n    const scrollbarRef = ref();\n    const wrapRef = ref();\n    const resizeRef = ref();\n    const barRef = ref();\n    const wrapStyle = computed(() => {\n      const style = {};\n      if (props.height) style.height = addUnit(props.height);\n      if (props.maxHeight) style.maxHeight = addUnit(props.maxHeight);\n      return [props.wrapStyle, style];\n    });\n    const wrapKls = computed(() => {\n      return [props.wrapClass, ns.e(\"wrap\"), {\n        [ns.em(\"wrap\", \"hidden-default\")]: !props.native\n      }];\n    });\n    const resizeKls = computed(() => {\n      return [ns.e(\"view\"), props.viewClass];\n    });\n    const shouldSkipDirection = direction2 => {\n      var _a;\n      return (_a = distanceScrollState[direction2]) != null ? _a : false;\n    };\n    const DIRECTION_PAIRS = {\n      top: \"bottom\",\n      bottom: \"top\",\n      left: \"right\",\n      right: \"left\"\n    };\n    const updateTriggerStatus = arrivedStates => {\n      const oppositeDirection = DIRECTION_PAIRS[direction];\n      if (!oppositeDirection) return;\n      const arrived = arrivedStates[direction];\n      const oppositeArrived = arrivedStates[oppositeDirection];\n      if (arrived && !distanceScrollState[direction]) {\n        distanceScrollState[direction] = true;\n      }\n      if (!oppositeArrived && distanceScrollState[oppositeDirection]) {\n        distanceScrollState[oppositeDirection] = false;\n      }\n    };\n    const handleScroll = () => {\n      var _a;\n      if (wrapRef.value) {\n        (_a = barRef.value) == null ? void 0 : _a.handleScroll(wrapRef.value);\n        const prevTop = wrapScrollTop;\n        const prevLeft = wrapScrollLeft;\n        wrapScrollTop = wrapRef.value.scrollTop;\n        wrapScrollLeft = wrapRef.value.scrollLeft;\n        const arrivedStates = {\n          bottom: wrapScrollTop + wrapRef.value.clientHeight >= wrapRef.value.scrollHeight - props.distance,\n          top: wrapScrollTop <= props.distance && prevTop !== 0,\n          right: wrapScrollLeft + wrapRef.value.clientWidth >= wrapRef.value.scrollWidth - props.distance && prevLeft !== wrapScrollLeft,\n          left: wrapScrollLeft <= props.distance && prevLeft !== 0\n        };\n        emit(\"scroll\", {\n          scrollTop: wrapScrollTop,\n          scrollLeft: wrapScrollLeft\n        });\n        if (prevTop !== wrapScrollTop) {\n          direction = wrapScrollTop > prevTop ? \"bottom\" : \"top\";\n        }\n        if (prevLeft !== wrapScrollLeft) {\n          direction = wrapScrollLeft > prevLeft ? \"right\" : \"left\";\n        }\n        if (props.distance > 0) {\n          if (shouldSkipDirection(direction)) {\n            return;\n          }\n          updateTriggerStatus(arrivedStates);\n        }\n        if (arrivedStates[direction]) emit(\"end-reached\", direction);\n      }\n    };\n    function scrollTo(arg1, arg2) {\n      if (isObject(arg1)) {\n        wrapRef.value.scrollTo(arg1);\n      } else if (isNumber(arg1) && isNumber(arg2)) {\n        wrapRef.value.scrollTo(arg1, arg2);\n      }\n    }\n    const setScrollTop = value => {\n      if (!isNumber(value)) {\n        return;\n      }\n      wrapRef.value.scrollTop = value;\n    };\n    const setScrollLeft = value => {\n      if (!isNumber(value)) {\n        return;\n      }\n      wrapRef.value.scrollLeft = value;\n    };\n    const update = () => {\n      var _a;\n      (_a = barRef.value) == null ? void 0 : _a.update();\n      distanceScrollState[direction] = false;\n    };\n    watch(() => props.noresize, noresize => {\n      if (noresize) {\n        stopResizeObserver == null ? void 0 : stopResizeObserver();\n        stopWrapResizeObserver == null ? void 0 : stopWrapResizeObserver();\n        stopResizeListener == null ? void 0 : stopResizeListener();\n      } else {\n        ({\n          stop: stopResizeObserver\n        } = useResizeObserver(resizeRef, update));\n        ({\n          stop: stopWrapResizeObserver\n        } = useResizeObserver(wrapRef, update));\n        stopResizeListener = useEventListener(\"resize\", update);\n      }\n    }, {\n      immediate: true\n    });\n    watch(() => [props.maxHeight, props.height], () => {\n      if (!props.native) nextTick(() => {\n        var _a;\n        update();\n        if (wrapRef.value) {\n          (_a = barRef.value) == null ? void 0 : _a.handleScroll(wrapRef.value);\n        }\n      });\n    });\n    provide(scrollbarContextKey, reactive({\n      scrollbarElement: scrollbarRef,\n      wrapElement: wrapRef\n    }));\n    onActivated(() => {\n      if (wrapRef.value) {\n        wrapRef.value.scrollTop = wrapScrollTop;\n        wrapRef.value.scrollLeft = wrapScrollLeft;\n      }\n    });\n    onMounted(() => {\n      if (!props.native) nextTick(() => {\n        update();\n      });\n    });\n    onUpdated(() => update());\n    expose({\n      wrapRef,\n      update,\n      scrollTo,\n      setScrollTop,\n      setScrollLeft,\n      handleScroll\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"scrollbarRef\",\n        ref: scrollbarRef,\n        class: normalizeClass(unref(ns).b())\n      }, [createElementVNode(\"div\", {\n        ref_key: \"wrapRef\",\n        ref: wrapRef,\n        class: normalizeClass(unref(wrapKls)),\n        style: normalizeStyle(unref(wrapStyle)),\n        tabindex: _ctx.tabindex,\n        onScroll: handleScroll\n      }, [(openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {\n        id: _ctx.id,\n        ref_key: \"resizeRef\",\n        ref: resizeRef,\n        class: normalizeClass(unref(resizeKls)),\n        style: normalizeStyle(_ctx.viewStyle),\n        role: _ctx.role,\n        \"aria-label\": _ctx.ariaLabel,\n        \"aria-orientation\": _ctx.ariaOrientation\n      }, {\n        default: withCtx(() => [renderSlot(_ctx.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"id\", \"class\", \"style\", \"role\", \"aria-label\", \"aria-orientation\"]))], 46, [\"tabindex\"]), !_ctx.native ? (openBlock(), createBlock(Bar, {\n        key: 0,\n        ref_key: \"barRef\",\n        ref: barRef,\n        always: _ctx.always,\n        \"min-size\": _ctx.minSize\n      }, null, 8, [\"always\", \"min-size\"])) : createCommentVNode(\"v-if\", true)], 2);\n    };\n  }\n});\nvar Scrollbar = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"scrollbar.vue\"]]);\nexport { Scrollbar as default };","map":{"version":3,"names":["name","COMPONENT_NAME","ns","useNamespace","stopResizeObserver","stopWrapResizeObserver","stopResizeListener","wrapScrollTop","wrapScrollLeft","direction","distanceScrollState","bottom","top","right","left","scrollbarRef","ref","wrapRef","resizeRef","barRef","wrapStyle","computed","style","props","height","addUnit","maxHeight","wrapKls","wrapClass","e","em","native","resizeKls","viewClass","shouldSkipDirection","direction2","_a","DIRECTION_PAIRS","updateTriggerStatus","arrivedStates","oppositeDirection","arrived","oppositeArrived","handleScroll","value","prevTop","prevLeft","scrollTop","scrollLeft","clientHeight","scrollHeight","distance","clientWidth","scrollWidth","emit","scrollTo","arg1","arg2","isObject","isNumber","setScrollTop","setScrollLeft","update","watch","noresize","stop","useResizeObserver","useEventListener","immediate","nextTick","provide","scrollbarContextKey","reactive","scrollbarElement","wrapElement","onActivated","onMounted","onUpdated","expose","_ctx","_cache","openBlock","createElementBlock","ref_key","class","normalizeClass","unref","b","createElementVNode"],"sources":["../../../../../../packages/components/scrollbar/src/scrollbar.vue"],"sourcesContent":["<template>\n  <div ref=\"scrollbarRef\" :class=\"ns.b()\">\n    <div\n      ref=\"wrapRef\"\n      :class=\"wrapKls\"\n      :style=\"wrapStyle\"\n      :tabindex=\"tabindex\"\n      @scroll=\"handleScroll\"\n    >\n      <component\n        :is=\"tag\"\n        :id=\"id\"\n        ref=\"resizeRef\"\n        :class=\"resizeKls\"\n        :style=\"viewStyle\"\n        :role=\"role\"\n        :aria-label=\"ariaLabel\"\n        :aria-orientation=\"ariaOrientation\"\n      >\n        <slot />\n      </component>\n    </div>\n    <template v-if=\"!native\">\n      <bar ref=\"barRef\" :always=\"always\" :min-size=\"minSize\" />\n    </template>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  nextTick,\n  onActivated,\n  onMounted,\n  onUpdated,\n  provide,\n  reactive,\n  ref,\n  watch,\n} from 'vue'\nimport { useEventListener, useResizeObserver } from '@vueuse/core'\nimport { addUnit, debugWarn, isNumber, isObject } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport Bar from './bar.vue'\nimport { scrollbarContextKey } from './constants'\nimport { scrollbarEmits, scrollbarProps } from './scrollbar'\n\nimport type { ScrollbarDirection } from './scrollbar'\nimport type { BarInstance } from './bar'\nimport type { CSSProperties, StyleValue } from 'vue'\n\nconst COMPONENT_NAME = 'ElScrollbar'\n\ndefineOptions({\n  name: COMPONENT_NAME,\n})\n\nconst props = defineProps(scrollbarProps)\nconst emit = defineEmits(scrollbarEmits)\n\nconst ns = useNamespace('scrollbar')\n\nlet stopResizeObserver: (() => void) | undefined = undefined\nlet stopWrapResizeObserver: (() => void) | undefined = undefined\nlet stopResizeListener: (() => void) | undefined = undefined\nlet wrapScrollTop = 0\nlet wrapScrollLeft = 0\nlet direction = '' as ScrollbarDirection\nconst distanceScrollState = {\n  bottom: false,\n  top: false,\n  right: false,\n  left: false,\n}\n\nconst scrollbarRef = ref<HTMLDivElement>()\nconst wrapRef = ref<HTMLDivElement>()\nconst resizeRef = ref<HTMLElement>()\nconst barRef = ref<BarInstance>()\n\nconst wrapStyle = computed<StyleValue>(() => {\n  const style: CSSProperties = {}\n  if (props.height) style.height = addUnit(props.height)\n  if (props.maxHeight) style.maxHeight = addUnit(props.maxHeight)\n  return [props.wrapStyle, style]\n})\n\nconst wrapKls = computed(() => {\n  return [\n    props.wrapClass,\n    ns.e('wrap'),\n    { [ns.em('wrap', 'hidden-default')]: !props.native },\n  ]\n})\n\nconst resizeKls = computed(() => {\n  return [ns.e('view'), props.viewClass]\n})\n\nconst shouldSkipDirection = (direction: ScrollbarDirection) => {\n  return distanceScrollState[direction] ?? false\n}\n\nconst DIRECTION_PAIRS: Record<ScrollbarDirection, ScrollbarDirection> = {\n  top: 'bottom',\n  bottom: 'top',\n  left: 'right',\n  right: 'left',\n}\nconst updateTriggerStatus = (arrivedStates: Record<string, boolean>) => {\n  const oppositeDirection = DIRECTION_PAIRS[direction]\n  if (!oppositeDirection) return\n\n  const arrived = arrivedStates[direction]\n  const oppositeArrived = arrivedStates[oppositeDirection]\n\n  if (arrived && !distanceScrollState[direction]) {\n    distanceScrollState[direction] = true\n  }\n\n  if (!oppositeArrived && distanceScrollState[oppositeDirection]) {\n    distanceScrollState[oppositeDirection] = false\n  }\n}\n\nconst handleScroll = () => {\n  if (wrapRef.value) {\n    barRef.value?.handleScroll(wrapRef.value)\n    const prevTop = wrapScrollTop\n    const prevLeft = wrapScrollLeft\n    wrapScrollTop = wrapRef.value.scrollTop\n    wrapScrollLeft = wrapRef.value.scrollLeft\n\n    const arrivedStates = {\n      bottom:\n        wrapScrollTop + wrapRef.value.clientHeight >=\n        wrapRef.value.scrollHeight - props.distance,\n      top: wrapScrollTop <= props.distance && prevTop !== 0,\n      right:\n        wrapScrollLeft + wrapRef.value.clientWidth >=\n          wrapRef.value.scrollWidth - props.distance &&\n        prevLeft !== wrapScrollLeft,\n      left: wrapScrollLeft <= props.distance && prevLeft !== 0,\n    }\n\n    emit('scroll', {\n      scrollTop: wrapScrollTop,\n      scrollLeft: wrapScrollLeft,\n    })\n\n    if (prevTop !== wrapScrollTop) {\n      direction = wrapScrollTop > prevTop ? 'bottom' : 'top'\n    }\n    if (prevLeft !== wrapScrollLeft) {\n      direction = wrapScrollLeft > prevLeft ? 'right' : 'left'\n    }\n    if (props.distance > 0) {\n      if (shouldSkipDirection(direction)) {\n        return\n      }\n      updateTriggerStatus(arrivedStates)\n    }\n    if (arrivedStates[direction]) emit('end-reached', direction)\n  }\n}\n\nfunction scrollTo(xCord: number, yCord?: number): void\nfunction scrollTo(options: ScrollToOptions): void\nfunction scrollTo(arg1: unknown, arg2?: number) {\n  if (isObject(arg1)) {\n    wrapRef.value!.scrollTo(arg1)\n  } else if (isNumber(arg1) && isNumber(arg2)) {\n    wrapRef.value!.scrollTo(arg1, arg2)\n  }\n}\n\nconst setScrollTop = (value: number) => {\n  if (!isNumber(value)) {\n    debugWarn(COMPONENT_NAME, 'value must be a number')\n    return\n  }\n  wrapRef.value!.scrollTop = value\n}\n\nconst setScrollLeft = (value: number) => {\n  if (!isNumber(value)) {\n    debugWarn(COMPONENT_NAME, 'value must be a number')\n    return\n  }\n  wrapRef.value!.scrollLeft = value\n}\n\nconst update = () => {\n  barRef.value?.update()\n  distanceScrollState[direction] = false\n}\n\nwatch(\n  () => props.noresize,\n  (noresize) => {\n    if (noresize) {\n      stopResizeObserver?.()\n      stopWrapResizeObserver?.()\n      stopResizeListener?.()\n    } else {\n      ;({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update))\n      ;({ stop: stopWrapResizeObserver } = useResizeObserver(wrapRef, update))\n      stopResizeListener = useEventListener('resize', update)\n    }\n  },\n  { immediate: true }\n)\n\nwatch(\n  () => [props.maxHeight, props.height],\n  () => {\n    if (!props.native)\n      nextTick(() => {\n        update()\n        if (wrapRef.value) {\n          barRef.value?.handleScroll(wrapRef.value)\n        }\n      })\n  }\n)\n\nprovide(\n  scrollbarContextKey,\n  reactive({\n    scrollbarElement: scrollbarRef,\n    wrapElement: wrapRef,\n  })\n)\n\nonActivated(() => {\n  if (wrapRef.value) {\n    wrapRef.value.scrollTop = wrapScrollTop\n    wrapRef.value.scrollLeft = wrapScrollLeft\n  }\n})\n\nonMounted(() => {\n  if (!props.native)\n    nextTick(() => {\n      update()\n    })\n})\nonUpdated(() => update())\n\ndefineExpose({\n  /** @description scrollbar wrap ref */\n  wrapRef,\n  /** @description update scrollbar state manually */\n  update,\n  /** @description scrolls to a particular set of coordinates */\n  scrollTo,\n  /** @description set distance to scroll top */\n  setScrollTop,\n  /** @description set distance to scroll left */\n  setScrollLeft,\n  /** @description handle scroll event */\n  handleScroll,\n})\n</script>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}