{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { ref, onMounted, onBeforeUnmount } from 'vue';\nimport { FOCUSOUT_PREVENTED, FOCUSOUT_PREVENTED_OPTS } from './tokens.mjs';\nimport { focusElement } from '../../../utils/dom/aria.mjs';\nconst focusReason = ref();\nconst lastUserFocusTimestamp = ref(0);\nconst lastAutomatedFocusTimestamp = ref(0);\nlet focusReasonUserCount = 0;\nconst obtainAllFocusableElements = element => {\n  const nodes = [];\n  const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n  return nodes;\n};\nconst getVisibleElement = (elements, container) => {\n  for (const element of elements) {\n    if (!isHidden(element, container)) return element;\n  }\n};\nconst isHidden = (element, container) => {\n  if (getComputedStyle(element).visibility === \"hidden\") return true;\n  while (element) {\n    if (container && element === container) return false;\n    if (getComputedStyle(element).display === \"none\") return true;\n    element = element.parentElement;\n  }\n  return false;\n};\nconst getEdges = container => {\n  const focusable = obtainAllFocusableElements(container);\n  const first = getVisibleElement(focusable, container);\n  const last = getVisibleElement(focusable.reverse(), container);\n  return [first, last];\n};\nconst isSelectable = element => {\n  return element instanceof HTMLInputElement && \"select\" in element;\n};\nconst tryFocus = (element, shouldSelect) => {\n  if (element) {\n    const prevFocusedElement = document.activeElement;\n    focusElement(element, {\n      preventScroll: true\n    });\n    lastAutomatedFocusTimestamp.value = window.performance.now();\n    if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {\n      element.select();\n    }\n  }\n};\nfunction removeFromStack(list, item) {\n  const copy = [...list];\n  const idx = list.indexOf(item);\n  if (idx !== -1) {\n    copy.splice(idx, 1);\n  }\n  return copy;\n}\nconst createFocusableStack = () => {\n  let stack = [];\n  const push = layer => {\n    const currentLayer = stack[0];\n    if (currentLayer && layer !== currentLayer) {\n      currentLayer.pause();\n    }\n    stack = removeFromStack(stack, layer);\n    stack.unshift(layer);\n  };\n  const remove = layer => {\n    var _a, _b;\n    stack = removeFromStack(stack, layer);\n    (_b = (_a = stack[0]) == null ? void 0 : _a.resume) == null ? void 0 : _b.call(_a);\n  };\n  return {\n    push,\n    remove\n  };\n};\nconst focusFirstDescendant = (elements, shouldSelect = false) => {\n  const prevFocusedElement = document.activeElement;\n  for (const element of elements) {\n    tryFocus(element, shouldSelect);\n    if (document.activeElement !== prevFocusedElement) return;\n  }\n};\nconst focusableStack = createFocusableStack();\nconst isFocusCausedByUserEvent = () => {\n  return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;\n};\nconst notifyFocusReasonPointer = () => {\n  focusReason.value = \"pointer\";\n  lastUserFocusTimestamp.value = window.performance.now();\n};\nconst notifyFocusReasonKeydown = () => {\n  focusReason.value = \"keyboard\";\n  lastUserFocusTimestamp.value = window.performance.now();\n};\nconst useFocusReason = () => {\n  onMounted(() => {\n    if (focusReasonUserCount === 0) {\n      document.addEventListener(\"mousedown\", notifyFocusReasonPointer);\n      document.addEventListener(\"touchstart\", notifyFocusReasonPointer);\n      document.addEventListener(\"keydown\", notifyFocusReasonKeydown);\n    }\n    focusReasonUserCount++;\n  });\n  onBeforeUnmount(() => {\n    focusReasonUserCount--;\n    if (focusReasonUserCount <= 0) {\n      document.removeEventListener(\"mousedown\", notifyFocusReasonPointer);\n      document.removeEventListener(\"touchstart\", notifyFocusReasonPointer);\n      document.removeEventListener(\"keydown\", notifyFocusReasonKeydown);\n    }\n  });\n  return {\n    focusReason,\n    lastUserFocusTimestamp,\n    lastAutomatedFocusTimestamp\n  };\n};\nconst createFocusOutPreventedEvent = detail => {\n  return new CustomEvent(FOCUSOUT_PREVENTED, {\n    ...FOCUSOUT_PREVENTED_OPTS,\n    detail\n  });\n};\nexport { createFocusOutPreventedEvent, focusFirstDescendant, focusableStack, getEdges, getVisibleElement, isFocusCausedByUserEvent, isHidden, obtainAllFocusableElements, tryFocus, useFocusReason };","map":{"version":3,"names":["focusReason","ref","lastUserFocusTimestamp","lastAutomatedFocusTimestamp","focusReasonUserCount","obtainAllFocusableElements","element","nodes","walker","document","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","node","isHiddenInput","tagName","type","disabled","hidden","FILTER_SKIP","tabIndex","activeElement","FILTER_ACCEPT","nextNode","push","currentNode","getVisibleElement","elements","container","isHidden","getComputedStyle","visibility","display","parentElement","getEdges","focusable","first","last","reverse","isSelectable","HTMLInputElement","tryFocus","shouldSelect","prevFocusedElement","focusElement","preventScroll","value","window","performance","now","select","removeFromStack","list","item","copy","idx","indexOf","splice","createFocusableStack","stack","layer","currentLayer","pause","unshift","remove","_a","_b","resume","call","focusFirstDescendant","focusableStack","isFocusCausedByUserEvent","notifyFocusReasonPointer","notifyFocusReasonKeydown","useFocusReason","onMounted","addEventListener","onBeforeUnmount","removeEventListener","createFocusOutPreventedEvent","detail","CustomEvent","FOCUSOUT_PREVENTED","FOCUSOUT_PREVENTED_OPTS"],"sources":["../../../../../../packages/components/focus-trap/src/utils.ts"],"sourcesContent":["import { onBeforeUnmount, onMounted, ref } from 'vue'\nimport { focusElement } from '@element-plus/utils'\nimport { FOCUSOUT_PREVENTED, FOCUSOUT_PREVENTED_OPTS } from './tokens'\n\nconst focusReason = ref<'pointer' | 'keyboard'>()\nconst lastUserFocusTimestamp = ref<number>(0)\nconst lastAutomatedFocusTimestamp = ref<number>(0)\nlet focusReasonUserCount = 0\n\nexport type FocusLayer = {\n  paused: boolean\n  pause: () => void\n  resume: () => void\n}\n\nexport type FocusStack = FocusLayer[]\n\nexport const obtainAllFocusableElements = (\n  element: HTMLElement\n): HTMLElement[] => {\n  const nodes: HTMLElement[] = []\n  const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (\n      node: Element & {\n        disabled: boolean\n        hidden: boolean\n        type: string\n        tabIndex: number\n      }\n    ) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden'\n      if (node.disabled || node.hidden || isHiddenInput)\n        return NodeFilter.FILTER_SKIP\n      return node.tabIndex >= 0 || node === document.activeElement\n        ? NodeFilter.FILTER_ACCEPT\n        : NodeFilter.FILTER_SKIP\n    },\n  })\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement)\n\n  return nodes\n}\n\nexport const getVisibleElement = (\n  elements: HTMLElement[],\n  container: HTMLElement\n) => {\n  for (const element of elements) {\n    if (!isHidden(element, container)) return element\n  }\n}\n\nexport const isHidden = (element: HTMLElement, container: HTMLElement) => {\n  if (process.env.NODE_ENV === 'test') return false\n  if (getComputedStyle(element).visibility === 'hidden') return true\n\n  while (element) {\n    if (container && element === container) return false\n    if (getComputedStyle(element).display === 'none') return true\n    element = element.parentElement as HTMLElement\n  }\n\n  return false\n}\n\nexport const getEdges = (container: HTMLElement) => {\n  const focusable = obtainAllFocusableElements(container)\n  const first = getVisibleElement(focusable, container)\n  const last = getVisibleElement(focusable.reverse(), container)\n  return [first, last]\n}\n\nconst isSelectable = (\n  element: any\n): element is HTMLInputElement & { select: () => void } => {\n  return element instanceof HTMLInputElement && 'select' in element\n}\n\nexport const tryFocus = (\n  element?: HTMLElement | { focus: () => void } | null,\n  shouldSelect?: boolean\n) => {\n  if (element) {\n    const prevFocusedElement = document.activeElement\n\n    focusElement(element, { preventScroll: true })\n    lastAutomatedFocusTimestamp.value = window.performance.now()\n\n    if (\n      element !== prevFocusedElement &&\n      isSelectable(element) &&\n      shouldSelect\n    ) {\n      element.select()\n    }\n  }\n}\n\nfunction removeFromStack<T>(list: T[], item: T) {\n  const copy = [...list]\n\n  const idx = list.indexOf(item)\n\n  if (idx !== -1) {\n    copy.splice(idx, 1)\n  }\n  return copy\n}\n\nconst createFocusableStack = () => {\n  let stack = [] as FocusStack\n\n  const push = (layer: FocusLayer) => {\n    const currentLayer = stack[0]\n\n    if (currentLayer && layer !== currentLayer) {\n      currentLayer.pause()\n    }\n\n    stack = removeFromStack(stack, layer)\n    stack.unshift(layer)\n  }\n\n  const remove = (layer: FocusLayer) => {\n    stack = removeFromStack(stack, layer)\n    stack[0]?.resume?.()\n  }\n\n  return {\n    push,\n    remove,\n  }\n}\n\nexport const focusFirstDescendant = (\n  elements: HTMLElement[],\n  shouldSelect = false\n) => {\n  const prevFocusedElement = document.activeElement\n  for (const element of elements) {\n    tryFocus(element, shouldSelect)\n    if (document.activeElement !== prevFocusedElement) return\n  }\n}\n\nexport const focusableStack = createFocusableStack()\n\nexport const isFocusCausedByUserEvent = (): boolean => {\n  return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value\n}\n\nconst notifyFocusReasonPointer = () => {\n  focusReason.value = 'pointer'\n  lastUserFocusTimestamp.value = window.performance.now()\n}\n\nconst notifyFocusReasonKeydown = () => {\n  focusReason.value = 'keyboard'\n  lastUserFocusTimestamp.value = window.performance.now()\n}\n\nexport const useFocusReason = (): {\n  focusReason: typeof focusReason\n  lastUserFocusTimestamp: typeof lastUserFocusTimestamp\n  lastAutomatedFocusTimestamp: typeof lastAutomatedFocusTimestamp\n} => {\n  onMounted(() => {\n    if (focusReasonUserCount === 0) {\n      document.addEventListener('mousedown', notifyFocusReasonPointer)\n      document.addEventListener('touchstart', notifyFocusReasonPointer)\n      document.addEventListener('keydown', notifyFocusReasonKeydown)\n    }\n    focusReasonUserCount++\n  })\n\n  onBeforeUnmount(() => {\n    focusReasonUserCount--\n    if (focusReasonUserCount <= 0) {\n      document.removeEventListener('mousedown', notifyFocusReasonPointer)\n      document.removeEventListener('touchstart', notifyFocusReasonPointer)\n      document.removeEventListener('keydown', notifyFocusReasonKeydown)\n    }\n  })\n\n  return {\n    focusReason,\n    lastUserFocusTimestamp,\n    lastAutomatedFocusTimestamp,\n  }\n}\n\nexport const createFocusOutPreventedEvent = (\n  detail: CustomEventInit['detail']\n) => {\n  return new CustomEvent(FOCUSOUT_PREVENTED, {\n    ...FOCUSOUT_PREVENTED_OPTS,\n    detail,\n  })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}