{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport { createVNode, render, isVNode } from 'vue';\nimport { merge, flatMap, castArray, get, isNull } from 'lodash-unified';\nimport { ElTooltip } from '../../tooltip/index.mjs';\nimport { isArray, isString, isFunction, hasOwn, isObject } from '@vue/shared';\nimport { throwError } from '../../../utils/error.mjs';\nimport { isUndefined, isNumber, isBoolean } from '../../../utils/types.mjs';\nimport { getProp } from '../../../utils/objects.mjs';\nconst getCell = function (event) {\n  var _a;\n  return (_a = event.target) == null ? void 0 : _a.closest(\"td\");\n};\nconst orderBy = function (array, sortKey, reverse, sortMethod, sortBy) {\n  if (!sortKey && !sortMethod && (!sortBy || isArray(sortBy) && !sortBy.length)) {\n    return array;\n  }\n  if (isString(reverse)) {\n    reverse = reverse === \"descending\" ? -1 : 1;\n  } else {\n    reverse = reverse && reverse < 0 ? -1 : 1;\n  }\n  const getKey = sortMethod ? null : function (value, index) {\n    if (sortBy) {\n      return flatMap(castArray(sortBy), by => {\n        if (isString(by)) {\n          return get(value, by);\n        } else {\n          return by(value, index, array);\n        }\n      });\n    }\n    if (sortKey !== \"$key\") {\n      if (isObject(value) && \"$value\" in value) value = value.$value;\n    }\n    return [isObject(value) ? sortKey ? get(value, sortKey) : null : value];\n  };\n  const compare = function (a, b) {\n    var _a, _b, _c, _d, _e, _f;\n    if (sortMethod) {\n      return sortMethod(a.value, b.value);\n    }\n    for (let i = 0, len = (_b = (_a = a.key) == null ? void 0 : _a.length) != null ? _b : 0; i < len; i++) {\n      if (((_c = a.key) == null ? void 0 : _c[i]) < ((_d = b.key) == null ? void 0 : _d[i])) {\n        return -1;\n      }\n      if (((_e = a.key) == null ? void 0 : _e[i]) > ((_f = b.key) == null ? void 0 : _f[i])) {\n        return 1;\n      }\n    }\n    return 0;\n  };\n  return array.map((value, index) => {\n    return {\n      value,\n      index,\n      key: getKey ? getKey(value, index) : null\n    };\n  }).sort((a, b) => {\n    let order = compare(a, b);\n    if (!order) {\n      order = a.index - b.index;\n    }\n    return order * +reverse;\n  }).map(item => item.value);\n};\nconst getColumnById = function (table, columnId) {\n  let column = null;\n  table.columns.forEach(item => {\n    if (item.id === columnId) {\n      column = item;\n    }\n  });\n  return column;\n};\nconst getColumnByKey = function (table, columnKey) {\n  let column = null;\n  for (let i = 0; i < table.columns.length; i++) {\n    const item = table.columns[i];\n    if (item.columnKey === columnKey) {\n      column = item;\n      break;\n    }\n  }\n  if (!column) throwError(\"ElTable\", `No column matching with column-key: ${columnKey}`);\n  return column;\n};\nconst getColumnByCell = function (table, cell, namespace) {\n  const matches = (cell.className || \"\").match(new RegExp(`${namespace}-table_[^\\\\s]+`, \"gm\"));\n  if (matches) {\n    return getColumnById(table, matches[0]);\n  }\n  return null;\n};\nconst getRowIdentity = (row, rowKey) => {\n  if (!row) throw new Error(\"Row is required when get row identity\");\n  if (isString(rowKey)) {\n    if (!rowKey.includes(\".\")) {\n      return `${row[rowKey]}`;\n    }\n    const key = rowKey.split(\".\");\n    let current = row;\n    for (const element of key) {\n      current = current[element];\n    }\n    return `${current}`;\n  } else if (isFunction(rowKey)) {\n    return rowKey.call(null, row);\n  }\n  return \"\";\n};\nconst getKeysMap = function (array, rowKey, flatten = false, childrenKey = \"children\") {\n  const data = array || [];\n  const arrayMap = {};\n  data.forEach((row, index) => {\n    arrayMap[getRowIdentity(row, rowKey)] = {\n      row,\n      index\n    };\n    if (flatten) {\n      const children = row[childrenKey];\n      if (isArray(children)) {\n        Object.assign(arrayMap, getKeysMap(children, rowKey, true, childrenKey));\n      }\n    }\n  });\n  return arrayMap;\n};\nfunction mergeOptions(defaults, config) {\n  const options = {};\n  let key;\n  for (key in defaults) {\n    options[key] = defaults[key];\n  }\n  for (key in config) {\n    if (hasOwn(config, key)) {\n      const value = config[key];\n      if (!isUndefined(value)) {\n        options[key] = value;\n      }\n    }\n  }\n  return options;\n}\nfunction parseWidth(width) {\n  if (width === \"\") return width;\n  if (!isUndefined(width)) {\n    width = Number.parseInt(width, 10);\n    if (Number.isNaN(width)) {\n      width = \"\";\n    }\n  }\n  return width;\n}\nfunction parseMinWidth(minWidth) {\n  if (minWidth === \"\") return minWidth;\n  if (!isUndefined(minWidth)) {\n    minWidth = parseWidth(minWidth);\n    if (Number.isNaN(minWidth)) {\n      minWidth = 80;\n    }\n  }\n  return minWidth;\n}\nfunction parseHeight(height) {\n  if (isNumber(height)) {\n    return height;\n  }\n  if (isString(height)) {\n    if (/^\\d+(?:px)?$/.test(height)) {\n      return Number.parseInt(height, 10);\n    } else {\n      return height;\n    }\n  }\n  return null;\n}\nfunction compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg;\n  }\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\nfunction toggleRowStatus(statusArr, row, newVal, tableTreeProps, selectable, rowIndex, rowKey) {\n  let _rowIndex = rowIndex != null ? rowIndex : 0;\n  let changed = false;\n  const getIndex = () => {\n    if (!rowKey) {\n      return statusArr.indexOf(row);\n    }\n    const id = getRowIdentity(row, rowKey);\n    return statusArr.findIndex(item => getRowIdentity(item, rowKey) === id);\n  };\n  const index = getIndex();\n  const included = index !== -1;\n  const isRowSelectable = selectable == null ? void 0 : selectable.call(null, row, _rowIndex);\n  const toggleStatus = type => {\n    if (type === \"add\") {\n      statusArr.push(row);\n    } else {\n      statusArr.splice(index, 1);\n    }\n    changed = true;\n  };\n  const getChildrenCount = row2 => {\n    let count = 0;\n    const children = (tableTreeProps == null ? void 0 : tableTreeProps.children) && row2[tableTreeProps.children];\n    if (children && isArray(children)) {\n      count += children.length;\n      children.forEach(item => {\n        count += getChildrenCount(item);\n      });\n    }\n    return count;\n  };\n  if (!selectable || isRowSelectable) {\n    if (isBoolean(newVal)) {\n      if (newVal && !included) {\n        toggleStatus(\"add\");\n      } else if (!newVal && included) {\n        toggleStatus(\"remove\");\n      }\n    } else {\n      included ? toggleStatus(\"remove\") : toggleStatus(\"add\");\n    }\n  }\n  if (!(tableTreeProps == null ? void 0 : tableTreeProps.checkStrictly) && (tableTreeProps == null ? void 0 : tableTreeProps.children) && isArray(row[tableTreeProps.children])) {\n    row[tableTreeProps.children].forEach(item => {\n      const childChanged = toggleRowStatus(statusArr, item, newVal != null ? newVal : !included, tableTreeProps, selectable, _rowIndex + 1, rowKey);\n      _rowIndex += getChildrenCount(item) + 1;\n      if (childChanged) {\n        changed = childChanged;\n      }\n    });\n  }\n  return changed;\n}\nfunction walkTreeNode(root, cb, childrenKey = \"children\", lazyKey = \"hasChildren\", lazy = false) {\n  const isNil = array => !(isArray(array) && array.length);\n  function _walker(parent, children, level) {\n    cb(parent, children, level);\n    children.forEach(item => {\n      if (item[lazyKey] && lazy) {\n        cb(item, null, level + 1);\n        return;\n      }\n      const children2 = item[childrenKey];\n      if (!isNil(children2)) {\n        _walker(item, children2, level + 1);\n      }\n    });\n  }\n  root.forEach(item => {\n    if (item[lazyKey] && lazy) {\n      cb(item, null, 0);\n      return;\n    }\n    const children = item[childrenKey];\n    if (!isNil(children)) {\n      _walker(item, children, 0);\n    }\n  });\n}\nconst getTableOverflowTooltipProps = (props, innerText, row, column) => {\n  const popperOptions = {\n    strategy: \"fixed\",\n    ...props.popperOptions\n  };\n  const tooltipFormatterContent = isFunction(column == null ? void 0 : column.tooltipFormatter) ? column.tooltipFormatter({\n    row,\n    column,\n    cellValue: getProp(row, column.property).value\n  }) : void 0;\n  if (isVNode(tooltipFormatterContent)) {\n    return {\n      slotContent: tooltipFormatterContent,\n      content: null,\n      ...props,\n      popperOptions\n    };\n  }\n  return {\n    slotContent: null,\n    content: tooltipFormatterContent != null ? tooltipFormatterContent : innerText,\n    ...props,\n    popperOptions\n  };\n};\nlet removePopper = null;\nfunction createTablePopper(props, popperContent, row, column, trigger, table) {\n  var _a;\n  const tableOverflowTooltipProps = getTableOverflowTooltipProps(props, popperContent, row, column);\n  const mergedProps = {\n    ...tableOverflowTooltipProps,\n    slotContent: void 0\n  };\n  if ((removePopper == null ? void 0 : removePopper.trigger) === trigger) {\n    const comp = (_a = removePopper.vm) == null ? void 0 : _a.component;\n    merge(comp == null ? void 0 : comp.props, mergedProps);\n    if (comp && tableOverflowTooltipProps.slotContent) {\n      comp.slots.content = () => [tableOverflowTooltipProps.slotContent];\n    }\n    return;\n  }\n  removePopper == null ? void 0 : removePopper();\n  const parentNode = table == null ? void 0 : table.refs.tableWrapper;\n  const ns = parentNode == null ? void 0 : parentNode.dataset.prefix;\n  const vm = createVNode(ElTooltip, {\n    virtualTriggering: true,\n    virtualRef: trigger,\n    appendTo: parentNode,\n    placement: \"top\",\n    transition: \"none\",\n    offset: 0,\n    hideAfter: 0,\n    ...mergedProps\n  }, tableOverflowTooltipProps.slotContent ? {\n    content: () => tableOverflowTooltipProps.slotContent\n  } : void 0);\n  vm.appContext = {\n    ...table.appContext,\n    ...table\n  };\n  const container = document.createElement(\"div\");\n  render(vm, container);\n  vm.component.exposed.onOpen();\n  const scrollContainer = parentNode == null ? void 0 : parentNode.querySelector(`.${ns}-scrollbar__wrap`);\n  removePopper = () => {\n    var _a2, _b;\n    if ((_b = (_a2 = vm.component) == null ? void 0 : _a2.exposed) == null ? void 0 : _b.onClose) {\n      vm.component.exposed.onClose();\n    }\n    render(null, container);\n    const currentRemovePopper = removePopper;\n    scrollContainer == null ? void 0 : scrollContainer.removeEventListener(\"scroll\", currentRemovePopper);\n    currentRemovePopper.trigger = void 0;\n    currentRemovePopper.vm = void 0;\n    removePopper = null;\n  };\n  removePopper.trigger = trigger != null ? trigger : void 0;\n  removePopper.vm = vm;\n  scrollContainer == null ? void 0 : scrollContainer.addEventListener(\"scroll\", removePopper);\n}\nfunction getCurrentColumns(column) {\n  if (column.children) {\n    return flatMap(column.children, getCurrentColumns);\n  } else {\n    return [column];\n  }\n}\nfunction getColSpan(colSpan, column) {\n  return colSpan + column.colSpan;\n}\nconst isFixedColumn = (index, fixed, store, realColumns) => {\n  let start = 0;\n  let after = index;\n  const columns = store.states.columns.value;\n  if (realColumns) {\n    const curColumns = getCurrentColumns(realColumns[index]);\n    const preColumns = columns.slice(0, columns.indexOf(curColumns[0]));\n    start = preColumns.reduce(getColSpan, 0);\n    after = start + curColumns.reduce(getColSpan, 0) - 1;\n  } else {\n    start = index;\n  }\n  let fixedLayout;\n  switch (fixed) {\n    case \"left\":\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = \"left\";\n      }\n      break;\n    case \"right\":\n      if (start >= columns.length - store.states.rightFixedLeafColumnsLength.value) {\n        fixedLayout = \"right\";\n      }\n      break;\n    default:\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = \"left\";\n      } else if (start >= columns.length - store.states.rightFixedLeafColumnsLength.value) {\n        fixedLayout = \"right\";\n      }\n  }\n  return fixedLayout ? {\n    direction: fixedLayout,\n    start,\n    after\n  } : {};\n};\nconst getFixedColumnsClass = (namespace, index, fixed, store, realColumns, offset = 0) => {\n  const classes = [];\n  const {\n    direction,\n    start,\n    after\n  } = isFixedColumn(index, fixed, store, realColumns);\n  if (direction) {\n    const isLeft = direction === \"left\";\n    classes.push(`${namespace}-fixed-column--${direction}`);\n    if (isLeft && after + offset === store.states.fixedLeafColumnsLength.value - 1) {\n      classes.push(\"is-last-column\");\n    } else if (!isLeft && start - offset === store.states.columns.value.length - store.states.rightFixedLeafColumnsLength.value) {\n      classes.push(\"is-first-column\");\n    }\n  }\n  return classes;\n};\nfunction getOffset(offset, column) {\n  return offset + (isNull(column.realWidth) || Number.isNaN(column.realWidth) ? Number(column.width) : column.realWidth);\n}\nconst getFixedColumnOffset = (index, fixed, store, realColumns) => {\n  const {\n    direction,\n    start = 0,\n    after = 0\n  } = isFixedColumn(index, fixed, store, realColumns);\n  if (!direction) {\n    return;\n  }\n  const styles = {};\n  const isLeft = direction === \"left\";\n  const columns = store.states.columns.value;\n  if (isLeft) {\n    styles.left = columns.slice(0, start).reduce(getOffset, 0);\n  } else {\n    styles.right = columns.slice(after + 1).reverse().reduce(getOffset, 0);\n  }\n  return styles;\n};\nconst ensurePosition = (style, key) => {\n  if (!style) return;\n  if (!Number.isNaN(style[key])) {\n    style[key] = `${style[key]}px`;\n  }\n};\nexport { compose, createTablePopper, ensurePosition, getCell, getColumnByCell, getColumnById, getColumnByKey, getFixedColumnOffset, getFixedColumnsClass, getKeysMap, getRowIdentity, isFixedColumn, mergeOptions, orderBy, parseHeight, parseMinWidth, parseWidth, removePopper, toggleRowStatus, walkTreeNode };","map":{"version":3,"names":["getCell","event","_a","target","closest","orderBy","array","sortKey","reverse","sortMethod","sortBy","isArray","length","isString","getKey","value","index","flatMap","castArray","by","get","isObject","$value","compare","a","b","_b","_c","_d","_e","_f","i","len","key","map","sort","order","item","getColumnById","table","columnId","column","columns","forEach","id","getColumnByKey","columnKey","throwError","getColumnByCell","cell","namespace","matches","className","match","RegExp","getRowIdentity","row","rowKey","Error","includes","split","current","element","isFunction","call","getKeysMap","flatten","childrenKey","data","arrayMap","children","Object","assign","mergeOptions","defaults","config","options","hasOwn","isUndefined","parseWidth","width","Number","parseInt","isNaN","parseMinWidth","minWidth","parseHeight","height","isNumber","test","compose","funcs","arg","reduce","args","toggleRowStatus","statusArr","newVal","tableTreeProps","selectable","rowIndex","_rowIndex","changed","getIndex","indexOf","findIndex","included","isRowSelectable","toggleStatus","type","push","splice","getChildrenCount","row2","count","isBoolean","checkStrictly","childChanged","walkTreeNode","root","cb","lazyKey","lazy","isNil","_walker","parent","level","children2","getTableOverflowTooltipProps","props","innerText","popperOptions","strategy","tooltipFormatterContent","tooltipFormatter","cellValue","getProp","property","isVNode","slotContent","content","removePopper","createTablePopper","popperContent","trigger","tableOverflowTooltipProps","mergedProps","comp","vm","component","merge","slots","parentNode","refs","tableWrapper","ns","dataset","prefix","createVNode","ElTooltip","virtualTriggering","virtualRef","appendTo","placement","transition","offset","hideAfter","appContext","container","document","createElement","render","exposed","onOpen","scrollContainer","querySelector","_a2","onClose","currentRemovePopper","removeEventListener","addEventListener","getCurrentColumns","getColSpan","colSpan","isFixedColumn","fixed","store","realColumns","start","after","states","curColumns","preColumns","slice","fixedLayout","fixedLeafColumnsLength","rightFixedLeafColumnsLength","direction","getFixedColumnsClass","classes","isLeft","getOffset","isNull","realWidth","getFixedColumnOffset","styles","left","right","ensurePosition","style"],"sources":["../../../../../../packages/components/table/src/util.ts"],"sourcesContent":["import { createVNode, isVNode, render } from 'vue'\nimport { flatMap, get, isNull, merge } from 'lodash-unified'\nimport {\n  ensureArray,\n  getProp,\n  hasOwn,\n  isArray,\n  isBoolean,\n  isFunction,\n  isNumber,\n  isObject,\n  isString,\n  isUndefined,\n  throwError,\n} from '@element-plus/utils'\nimport ElTooltip, {\n  type ElTooltipProps,\n} from '@element-plus/components/tooltip'\n\nimport type { DefaultRow, Table, TreeProps } from './table/defaults'\nimport type { TableColumnCtx } from './table-column/defaults'\nimport type { CSSProperties, VNode } from 'vue'\n\nexport type TableOverflowTooltipOptions = Partial<\n  Pick<\n    ElTooltipProps,\n    | 'appendTo'\n    | 'effect'\n    | 'enterable'\n    | 'hideAfter'\n    | 'offset'\n    | 'placement'\n    | 'popperClass'\n    | 'popperOptions'\n    | 'showAfter'\n    | 'showArrow'\n    | 'transition'\n  >\n>\n\nexport type TableOverflowTooltipFormatter<T extends DefaultRow> = (data: {\n  row: T\n  column: TableColumnCtx<T>\n  cellValue: any\n}) => VNode | string\n\ntype RemovePopperFn = (() => void) & {\n  trigger?: HTMLElement\n  vm?: VNode\n}\n\ntype CompareValue<T> = {\n  value: T\n  index: number\n  key: any[] | null\n}\n\nexport const getCell = function (event: Event) {\n  return (event.target as HTMLElement)?.closest('td')\n}\n\nexport const orderBy = function <T extends DefaultRow>(\n  array: T[],\n  sortKey: string | null,\n  reverse: string | number | null,\n  sortMethod: TableColumnCtx<T>['sortMethod'] | null,\n  sortBy: string | string[] | ((a: T, index: number, array?: T[]) => string)\n) {\n  if (\n    !sortKey &&\n    !sortMethod &&\n    (!sortBy || (isArray(sortBy) && !sortBy.length))\n  ) {\n    return array\n  }\n  if (isString(reverse)) {\n    reverse = reverse === 'descending' ? -1 : 1\n  } else {\n    reverse = reverse && reverse < 0 ? -1 : 1\n  }\n  const getKey = sortMethod\n    ? null\n    : function (value: T, index: number) {\n        if (sortBy) {\n          return flatMap(ensureArray(sortBy), (by) => {\n            if (isString(by)) {\n              return get(value, by)\n            } else {\n              return by(value, index, array)\n            }\n          })\n        }\n        if (sortKey !== '$key') {\n          if (isObject(value) && '$value' in value) value = value.$value\n        }\n        return [\n          isObject(value) ? (sortKey ? get(value, sortKey) : null) : value,\n        ]\n      }\n  const compare = function (a: CompareValue<T>, b: CompareValue<T>) {\n    if (sortMethod) {\n      return sortMethod(a.value, b.value)\n    }\n    for (let i = 0, len = a.key?.length ?? 0; i < len; i++) {\n      if (a.key?.[i] < b.key?.[i]) {\n        return -1\n      }\n      if (a.key?.[i] > b.key?.[i]) {\n        return 1\n      }\n    }\n    return 0\n  }\n  return array\n    .map<CompareValue<T>>((value: T, index) => {\n      return {\n        value,\n        index,\n        key: getKey ? getKey(value, index) : null,\n      }\n    })\n    .sort((a, b) => {\n      let order = compare(a, b)\n      if (!order) {\n        // make stable https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\n        order = a.index - b.index\n      }\n      return order * +reverse\n    })\n    .map((item) => item.value)\n}\n\nexport const getColumnById = function <T extends DefaultRow>(\n  table: {\n    columns: TableColumnCtx<T>[]\n  },\n  columnId: string\n): null | TableColumnCtx<T> {\n  let column = null\n  table.columns.forEach((item) => {\n    if (item.id === columnId) {\n      column = item\n    }\n  })\n  return column\n}\n\nexport const getColumnByKey = function <T extends DefaultRow>(\n  table: {\n    columns: TableColumnCtx<T>[]\n  },\n  columnKey: string\n): TableColumnCtx<T> {\n  let column = null\n  for (let i = 0; i < table.columns.length; i++) {\n    const item = table.columns[i]\n    if (item.columnKey === columnKey) {\n      column = item\n      break\n    }\n  }\n  if (!column)\n    throwError('ElTable', `No column matching with column-key: ${columnKey}`)\n  return column\n}\n\nexport const getColumnByCell = function <T extends DefaultRow>(\n  table: {\n    columns: TableColumnCtx<T>[]\n  },\n  cell: HTMLElement,\n  namespace: string\n): null | TableColumnCtx<T> {\n  const matches = (cell.className || '').match(\n    new RegExp(`${namespace}-table_[^\\\\s]+`, 'gm')\n  )\n  if (matches) {\n    return getColumnById(table, matches[0])\n  }\n  return null\n}\n\nexport const getRowIdentity = <T extends DefaultRow>(\n  row: T,\n  rowKey: string | ((row: T) => string) | null\n): string => {\n  if (!row) throw new Error('Row is required when get row identity')\n  if (isString(rowKey)) {\n    if (!rowKey.includes('.')) {\n      return `${row[rowKey]}`\n    }\n    const key = rowKey.split('.')\n    let current: any = row\n    for (const element of key) {\n      current = current[element]\n    }\n    //TODO: \"current\" is now any, we just satisfies typecheck here\n    // but this function can actually return a number\n    return `${current}`\n  } else if (isFunction(rowKey)) {\n    return rowKey.call(null, row)\n  }\n  return ''\n}\n\nexport const getKeysMap = function <T extends DefaultRow>(\n  array: T[],\n  rowKey: string | null,\n  flatten = false,\n  childrenKey = 'children'\n): Record<PropertyKey, { row: T; index: number }> {\n  const data = array || []\n  const arrayMap: Record<string, { row: T; index: number }> = {}\n\n  data.forEach((row, index) => {\n    arrayMap[getRowIdentity(row, rowKey)] = { row, index }\n\n    if (flatten) {\n      const children = row[childrenKey]\n      if (isArray(children)) {\n        Object.assign(arrayMap, getKeysMap(children, rowKey, true, childrenKey))\n      }\n    }\n  })\n\n  return arrayMap\n}\n\nexport function mergeOptions<T extends DefaultRow, K extends DefaultRow>(\n  defaults: T,\n  config: K\n): T & K {\n  const options = {} as T & K\n  let key: keyof T & keyof K\n  for (key in defaults) {\n    options[key] = defaults[key]\n  }\n  for (key in config) {\n    if (hasOwn(config, key)) {\n      const value = config[key]\n      if (!isUndefined(value)) {\n        options[key as keyof K] = value\n      }\n    }\n  }\n  return options\n}\n\nexport function parseWidth(width?: number | string): number | string {\n  if (width === '') return width\n  if (!isUndefined(width)) {\n    width = Number.parseInt(width as string, 10)\n    if (Number.isNaN(width)) {\n      width = ''\n    }\n  }\n  return width!\n}\n\nexport function parseMinWidth(minWidth: number | string): number | string {\n  if (minWidth === '') return minWidth\n  if (!isUndefined(minWidth)) {\n    minWidth = parseWidth(minWidth)\n    if (Number.isNaN(minWidth)) {\n      minWidth = 80\n    }\n  }\n  return minWidth\n}\n\nexport function parseHeight(height: number | string | null) {\n  if (isNumber(height)) {\n    return height\n  }\n  if (isString(height)) {\n    if (/^\\d+(?:px)?$/.test(height)) {\n      return Number.parseInt(height, 10)\n    } else {\n      return height\n    }\n  }\n  return null\n}\n\n// https://github.com/reduxjs/redux/blob/master/src/compose.ts\nexport function compose(...funcs: ((...args: any[]) => void)[]) {\n  if (funcs.length === 0) {\n    return <T>(arg: T) => arg\n  }\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n  return funcs.reduce(\n    (a, b) =>\n      (...args: any[]) =>\n        a(b(...args))\n  )\n}\n\nexport function toggleRowStatus<T extends DefaultRow>(\n  statusArr: T[],\n  row: T,\n  newVal?: boolean,\n  tableTreeProps?: TreeProps,\n  selectable?: ((row: T, index: number) => boolean) | null,\n  rowIndex?: number,\n  rowKey?: string | null\n): boolean {\n  let _rowIndex = rowIndex ?? 0\n  let changed = false\n\n  const getIndex = () => {\n    if (!rowKey) {\n      return statusArr.indexOf(row)\n    }\n\n    const id = getRowIdentity(row, rowKey)\n\n    return statusArr.findIndex((item) => getRowIdentity(item, rowKey) === id)\n  }\n\n  const index = getIndex()\n\n  const included = index !== -1\n  const isRowSelectable = selectable?.call(null, row, _rowIndex)\n\n  const toggleStatus = (type: 'add' | 'remove') => {\n    if (type === 'add') {\n      statusArr.push(row)\n    } else {\n      statusArr.splice(index, 1)\n    }\n    changed = true\n  }\n  const getChildrenCount = <T extends DefaultRow>(row: T) => {\n    let count = 0\n    const children = tableTreeProps?.children && row[tableTreeProps.children]\n    if (children && isArray(children)) {\n      count += children.length\n      children.forEach((item) => {\n        count += getChildrenCount(item)\n      })\n    }\n    return count\n  }\n\n  if (!selectable || isRowSelectable) {\n    if (isBoolean(newVal)) {\n      if (newVal && !included) {\n        toggleStatus('add')\n      } else if (!newVal && included) {\n        toggleStatus('remove')\n      }\n    } else {\n      included ? toggleStatus('remove') : toggleStatus('add')\n    }\n  }\n\n  if (\n    !tableTreeProps?.checkStrictly &&\n    tableTreeProps?.children &&\n    isArray(row[tableTreeProps.children])\n  ) {\n    row[tableTreeProps.children].forEach((item: T) => {\n      const childChanged = toggleRowStatus(\n        statusArr,\n        item,\n        newVal ?? !included,\n        tableTreeProps,\n        selectable,\n        _rowIndex + 1,\n        rowKey\n      )\n      _rowIndex += getChildrenCount(item) + 1\n      if (childChanged) {\n        changed = childChanged\n      }\n    })\n  }\n  return changed\n}\n\nexport function walkTreeNode<T extends DefaultRow>(\n  root: T[],\n  cb: (parent: any, children: T | T[] | null, level: number) => void,\n  childrenKey = 'children',\n  lazyKey = 'hasChildren',\n  lazy = false\n) {\n  const isNil = (array: any): array is null => !(isArray(array) && array.length)\n\n  function _walker(parent: any, children: T | T[], level: number) {\n    cb(parent, children, level)\n    children.forEach((item: any) => {\n      if (item[lazyKey] && lazy) {\n        cb(item, null, level + 1)\n        return\n      }\n      const children = item[childrenKey]\n      if (!isNil(children)) {\n        _walker(item, children, level + 1)\n      }\n    })\n  }\n\n  root.forEach((item: any) => {\n    if (item[lazyKey] && lazy) {\n      cb(item, null, 0)\n      return\n    }\n    const children = item[childrenKey]\n    if (!isNil(children)) {\n      _walker(item, children, 0)\n    }\n  })\n}\n\nconst getTableOverflowTooltipProps = <T extends DefaultRow>(\n  props: TableOverflowTooltipOptions,\n  innerText: string,\n  row: T,\n  column: TableColumnCtx<T> | null\n) => {\n  // merge popperOptions\n  const popperOptions = {\n    strategy: 'fixed',\n    ...props.popperOptions,\n  }\n\n  const tooltipFormatterContent = isFunction(column?.tooltipFormatter)\n    ? column.tooltipFormatter({\n        row,\n        column,\n        cellValue: getProp(row, column.property).value,\n      })\n    : undefined\n\n  if (isVNode(tooltipFormatterContent)) {\n    return {\n      slotContent: tooltipFormatterContent,\n      content: null,\n      ...props,\n      popperOptions,\n    }\n  }\n\n  return {\n    slotContent: null,\n    content: tooltipFormatterContent ?? innerText,\n    ...props,\n    popperOptions,\n  }\n}\n\nexport let removePopper: RemovePopperFn | null = null\n\nexport function createTablePopper<T extends DefaultRow>(\n  props: TableOverflowTooltipOptions,\n  popperContent: string,\n  row: T,\n  column: TableColumnCtx<T> | null,\n  trigger: HTMLElement | null,\n  table: Table<DefaultRow>\n) {\n  const tableOverflowTooltipProps = getTableOverflowTooltipProps(\n    props,\n    popperContent,\n    row,\n    column\n  )\n  const mergedProps = {\n    ...tableOverflowTooltipProps,\n    slotContent: undefined,\n  }\n  if (removePopper?.trigger === trigger) {\n    const comp = removePopper.vm?.component\n    merge(comp?.props, mergedProps)\n    if (comp && tableOverflowTooltipProps.slotContent) {\n      comp.slots.content = () => [tableOverflowTooltipProps.slotContent]\n    }\n    return\n  }\n  removePopper?.()\n  const parentNode = table?.refs.tableWrapper\n  const ns = parentNode?.dataset.prefix\n  const vm = createVNode(\n    ElTooltip,\n    {\n      virtualTriggering: true,\n      virtualRef: trigger,\n      appendTo: parentNode,\n      placement: 'top',\n      transition: 'none', // Default does not require transition\n      offset: 0,\n      hideAfter: 0,\n      ...mergedProps,\n    },\n    tableOverflowTooltipProps.slotContent\n      ? {\n          content: () => tableOverflowTooltipProps.slotContent,\n        }\n      : undefined\n  )\n  vm.appContext = { ...table.appContext, ...table }\n  const container = document.createElement('div')\n  render(vm, container)\n  vm.component!.exposed!.onOpen()\n  const scrollContainer = parentNode?.querySelector(`.${ns}-scrollbar__wrap`)\n  removePopper = () => {\n    if (vm.component?.exposed?.onClose) {\n      vm.component.exposed.onClose()\n    }\n    render(null, container)\n    const currentRemovePopper = removePopper as RemovePopperFn\n    scrollContainer?.removeEventListener('scroll', currentRemovePopper)\n    currentRemovePopper.trigger = undefined\n    currentRemovePopper.vm = undefined\n    removePopper = null\n  }\n  removePopper.trigger = trigger ?? undefined\n  removePopper.vm = vm\n  scrollContainer?.addEventListener('scroll', removePopper)\n}\n\nfunction getCurrentColumns<T extends DefaultRow>(\n  column: TableColumnCtx<T>\n): TableColumnCtx<T>[] {\n  if (column.children) {\n    return flatMap(column.children, getCurrentColumns)\n  } else {\n    return [column]\n  }\n}\n\nfunction getColSpan<T extends DefaultRow>(\n  colSpan: number,\n  column: TableColumnCtx<T>\n) {\n  return colSpan + column.colSpan\n}\n\nexport const isFixedColumn = <T extends DefaultRow>(\n  index: number,\n  fixed: string | boolean | undefined,\n  store: any,\n  realColumns?: TableColumnCtx<T>[]\n) => {\n  let start = 0\n  let after = index\n  const columns = store.states.columns.value\n  if (realColumns) {\n    // fixed column supported in grouped header\n    const curColumns = getCurrentColumns(realColumns[index])\n    const preColumns = columns.slice(0, columns.indexOf(curColumns[0]))\n\n    start = preColumns.reduce(getColSpan, 0)\n    after = start + curColumns.reduce(getColSpan, 0) - 1\n  } else {\n    start = index\n  }\n  let fixedLayout\n  switch (fixed) {\n    case 'left':\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = 'left'\n      }\n      break\n    case 'right':\n      if (\n        start >=\n        columns.length - store.states.rightFixedLeafColumnsLength.value\n      ) {\n        fixedLayout = 'right'\n      }\n      break\n    default:\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = 'left'\n      } else if (\n        start >=\n        columns.length - store.states.rightFixedLeafColumnsLength.value\n      ) {\n        fixedLayout = 'right'\n      }\n  }\n  return fixedLayout\n    ? {\n        direction: fixedLayout,\n        start,\n        after,\n      }\n    : {}\n}\n\nexport const getFixedColumnsClass = <T extends DefaultRow>(\n  namespace: string,\n  index: number,\n  fixed: string | boolean | undefined,\n  store: any,\n  realColumns?: TableColumnCtx<T>[],\n  offset = 0\n) => {\n  const classes: string[] = []\n  const { direction, start, after } = isFixedColumn(\n    index,\n    fixed,\n    store,\n    realColumns\n  )\n  if (direction) {\n    const isLeft = direction === 'left'\n    classes.push(`${namespace}-fixed-column--${direction}`)\n    if (\n      isLeft &&\n      after + offset === store.states.fixedLeafColumnsLength.value - 1\n    ) {\n      classes.push('is-last-column')\n    } else if (\n      !isLeft &&\n      start - offset ===\n        store.states.columns.value.length -\n          store.states.rightFixedLeafColumnsLength.value\n    ) {\n      classes.push('is-first-column')\n    }\n  }\n  return classes\n}\n\nfunction getOffset<T extends DefaultRow>(\n  offset: number,\n  column: TableColumnCtx<T>\n) {\n  return (\n    offset +\n    (isNull(column.realWidth) || Number.isNaN(column.realWidth)\n      ? Number(column.width)\n      : column.realWidth)\n  )\n}\n\nexport const getFixedColumnOffset = <T extends DefaultRow>(\n  index: number,\n  fixed: string | boolean | undefined,\n  store: any,\n  realColumns?: TableColumnCtx<T>[]\n) => {\n  const {\n    direction,\n    start = 0,\n    after = 0,\n  } = isFixedColumn(index, fixed, store, realColumns)\n  if (!direction) {\n    return\n  }\n  const styles: CSSProperties = {}\n  const isLeft = direction === 'left'\n  const columns = store.states.columns.value\n  if (isLeft) {\n    styles.left = columns.slice(0, start).reduce(getOffset, 0)\n  } else {\n    styles.right = columns\n      .slice(after + 1)\n      .reverse()\n      .reduce(getOffset, 0)\n  }\n  return styles\n}\n\nexport const ensurePosition = (\n  style: CSSProperties | undefined,\n  key: keyof CSSProperties\n) => {\n  if (!style) return\n  if (!Number.isNaN(style[key])) {\n    style[key] = `${style[key]}px` as any\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}