{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport { shallowRef, triggerRef, onMounted, defineComponent, h, isVNode } from 'vue';\nimport { flattedChildren } from '../../utils/vue/vnode.mjs';\nconst getOrderedChildren = (vm, childComponentName, children) => {\n  const nodes = flattedChildren(vm.subTree).filter(n => {\n    var _a;\n    return isVNode(n) && ((_a = n.type) == null ? void 0 : _a.name) === childComponentName && !!n.component;\n  });\n  const uids = nodes.map(n => n.component.uid);\n  return uids.map(uid => children[uid]).filter(p => !!p);\n};\nconst useOrderedChildren = (vm, childComponentName) => {\n  const children = shallowRef({});\n  const orderedChildren = shallowRef([]);\n  const nodesMap = /* @__PURE__ */new WeakMap();\n  const addChild = child => {\n    children.value[child.uid] = child;\n    triggerRef(children);\n    onMounted(() => {\n      const childNode = child.getVnode().el;\n      const parentNode = childNode.parentNode;\n      if (!nodesMap.has(parentNode)) {\n        nodesMap.set(parentNode, []);\n        const originalFn = parentNode.insertBefore.bind(parentNode);\n        parentNode.insertBefore = (node, anchor) => {\n          const shouldSortChildren = nodesMap.get(parentNode).some(el => node === el || anchor === el);\n          if (shouldSortChildren) triggerRef(children);\n          return originalFn(node, anchor);\n        };\n      }\n      nodesMap.get(parentNode).push(childNode);\n    });\n  };\n  const removeChild = child => {\n    delete children.value[child.uid];\n    triggerRef(children);\n    const childNode = child.getVnode().el;\n    const parentNode = childNode.parentNode;\n    const childNodes = nodesMap.get(parentNode);\n    const index = childNodes.indexOf(childNode);\n    childNodes.splice(index, 1);\n  };\n  const sortChildren = () => {\n    orderedChildren.value = getOrderedChildren(vm, childComponentName, children.value);\n  };\n  const IsolatedRenderer = props => {\n    return props.render();\n  };\n  const ChildrenSorter = defineComponent({\n    setup(_, {\n      slots\n    }) {\n      return () => {\n        sortChildren();\n        return slots.default ? h(IsolatedRenderer, {\n          render: slots.default\n        }) : null;\n      };\n    }\n  });\n  return {\n    children: orderedChildren,\n    addChild,\n    removeChild,\n    ChildrenSorter\n  };\n};\nexport { useOrderedChildren };","map":{"version":3,"names":["getOrderedChildren","vm","childComponentName","children","nodes","flattedChildren","subTree","filter","n","_a","isVNode","type","name","component","uids","map","uid","p","useOrderedChildren","shallowRef","orderedChildren","nodesMap","WeakMap","addChild","child","value","triggerRef","onMounted","childNode","getVnode","el","parentNode","has","set","originalFn","insertBefore","bind","node","anchor","shouldSortChildren","get","some","push","removeChild","childNodes","index","indexOf","splice","sortChildren","IsolatedRenderer","props","render","ChildrenSorter","defineComponent","setup","_","slots","default","h"],"sources":["../../../../../packages/hooks/use-ordered-children/index.ts"],"sourcesContent":["import {\n  defineComponent,\n  h,\n  isVNode,\n  onMounted,\n  shallowRef,\n  triggerRef,\n} from 'vue'\nimport { flattedChildren } from '@element-plus/utils'\n\nimport type { Component, ComponentInternalInstance, VNode } from 'vue'\n\ntype ChildEssential = {\n  uid: number\n  getVnode: () => VNode\n}\n\nconst getOrderedChildren = <T>(\n  vm: ComponentInternalInstance,\n  childComponentName: string,\n  children: Record<number, T>\n): T[] => {\n  const nodes = flattedChildren(vm.subTree).filter(\n    (n): n is VNode =>\n      isVNode(n) &&\n      (n.type as Component)?.name === childComponentName &&\n      !!n.component\n  )\n  const uids = nodes.map((n) => n.component!.uid)\n  return uids.map((uid) => children[uid]).filter((p) => !!p)\n}\n\nexport const useOrderedChildren = <T extends ChildEssential>(\n  vm: ComponentInternalInstance,\n  childComponentName: string\n) => {\n  const children = shallowRef<Record<number, T>>({})\n  const orderedChildren = shallowRef<T[]>([])\n  const nodesMap = new WeakMap<ParentNode, Node[]>()\n\n  const addChild = (child: T) => {\n    children.value[child.uid] = child\n    triggerRef(children)\n\n    onMounted(() => {\n      const childNode = child.getVnode().el! as Node\n      const parentNode = childNode.parentNode!\n\n      if (!nodesMap.has(parentNode)) {\n        nodesMap.set(parentNode, [])\n\n        const originalFn = parentNode.insertBefore.bind(parentNode)\n        parentNode.insertBefore = <T extends Node>(\n          node: T,\n          anchor: Node | null\n        ) => {\n          // Schedule a job to update `orderedChildren` if the root element of child components is moved\n          const shouldSortChildren = nodesMap\n            .get(parentNode)!\n            .some((el) => node === el || anchor === el)\n          if (shouldSortChildren) triggerRef(children)\n\n          return originalFn(node, anchor)\n        }\n      }\n\n      nodesMap.get(parentNode)!.push(childNode)\n    })\n  }\n\n  const removeChild = (child: T) => {\n    delete children.value[child.uid]\n    triggerRef(children)\n\n    const childNode = child.getVnode().el! as Node\n    const parentNode = childNode.parentNode!\n    const childNodes = nodesMap.get(parentNode)!\n    const index = childNodes.indexOf(childNode)\n    childNodes.splice(index, 1)\n  }\n\n  const sortChildren = () => {\n    orderedChildren.value = getOrderedChildren(\n      vm,\n      childComponentName,\n      children.value\n    )\n  }\n\n  const IsolatedRenderer = (props: { render: () => VNode[] }) => {\n    return props.render()\n  }\n\n  // TODO: Refactor `el-description` before converting this to a functional component\n  const ChildrenSorter = defineComponent({\n    setup(_, { slots }) {\n      return () => {\n        sortChildren()\n\n        return slots.default\n          ? // Create a new `ReactiveEffect` to ensure `ChildrenSorter` doesn't track any extra dependencies\n            // @ts-ignore TODO: Remove this after Vue is upgraded\n            h(IsolatedRenderer, {\n              render: slots.default,\n            })\n          : null\n      }\n    },\n  })\n\n  return {\n    children: orderedChildren,\n    addChild,\n    removeChild,\n    ChildrenSorter,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}