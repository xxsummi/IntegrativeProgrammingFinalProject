{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport { ref, computed, watch } from 'vue';\nimport { isPct, getPct, isPx, getPx } from './useSize.mjs';\nimport { NOOP } from '@vue/shared';\nfunction useResize(panels, containerSize, pxSizes, lazy) {\n  const ptg2px = ptg => ptg * containerSize.value || 0;\n  function getLimitSize(str, defaultLimit) {\n    if (isPct(str)) {\n      return ptg2px(getPct(str));\n    } else if (isPx(str)) {\n      return getPx(str);\n    }\n    return str != null ? str : defaultLimit;\n  }\n  const lazyOffset = ref(0);\n  const movingIndex = ref(null);\n  let cachePxSizes = [];\n  let updatePanelSizes = NOOP;\n  const limitSizes = computed(() => panels.value.map(item => [item.min, item.max]));\n  watch(lazy, () => {\n    if (lazyOffset.value) {\n      const mouseup = new MouseEvent(\"mouseup\", {\n        bubbles: true\n      });\n      window.dispatchEvent(mouseup);\n    }\n  });\n  const onMoveStart = index => {\n    lazyOffset.value = 0;\n    movingIndex.value = {\n      index,\n      confirmed: false\n    };\n    cachePxSizes = pxSizes.value;\n  };\n  const onMoving = (index, offset) => {\n    var _a, _b;\n    let confirmedIndex = null;\n    if ((!movingIndex.value || !movingIndex.value.confirmed) && offset !== 0) {\n      if (offset > 0) {\n        confirmedIndex = index;\n        movingIndex.value = {\n          index,\n          confirmed: true\n        };\n      } else {\n        for (let i = index; i >= 0; i -= 1) {\n          if (cachePxSizes[i] > 0) {\n            confirmedIndex = i;\n            movingIndex.value = {\n              index: i,\n              confirmed: true\n            };\n            break;\n          }\n        }\n      }\n    }\n    const mergedIndex = (_b = confirmedIndex != null ? confirmedIndex : (_a = movingIndex.value) == null ? void 0 : _a.index) != null ? _b : index;\n    const numSizes = [...cachePxSizes];\n    const nextIndex = mergedIndex + 1;\n    const startMinSize = getLimitSize(limitSizes.value[mergedIndex][0], 0);\n    const endMinSize = getLimitSize(limitSizes.value[nextIndex][0], 0);\n    const startMaxSize = getLimitSize(limitSizes.value[mergedIndex][1], containerSize.value || 0);\n    const endMaxSize = getLimitSize(limitSizes.value[nextIndex][1], containerSize.value || 0);\n    let mergedOffset = offset;\n    if (numSizes[mergedIndex] + mergedOffset < startMinSize) {\n      mergedOffset = startMinSize - numSizes[mergedIndex];\n    }\n    if (numSizes[nextIndex] - mergedOffset < endMinSize) {\n      mergedOffset = numSizes[nextIndex] - endMinSize;\n    }\n    if (numSizes[mergedIndex] + mergedOffset > startMaxSize) {\n      mergedOffset = startMaxSize - numSizes[mergedIndex];\n    }\n    if (numSizes[nextIndex] - mergedOffset > endMaxSize) {\n      mergedOffset = numSizes[nextIndex] - endMaxSize;\n    }\n    numSizes[mergedIndex] += mergedOffset;\n    numSizes[nextIndex] -= mergedOffset;\n    lazyOffset.value = mergedOffset;\n    updatePanelSizes = () => {\n      panels.value.forEach((panel, index2) => {\n        panel.size = numSizes[index2];\n      });\n      updatePanelSizes = NOOP;\n    };\n    if (!lazy.value) {\n      updatePanelSizes();\n    }\n  };\n  const onMoveEnd = () => {\n    if (lazy.value) {\n      updatePanelSizes();\n    }\n    lazyOffset.value = 0;\n    movingIndex.value = null;\n    cachePxSizes = [];\n  };\n  const cacheCollapsedSize = [];\n  const onCollapse = (index, type) => {\n    if (!cacheCollapsedSize.length) {\n      cacheCollapsedSize.push(...pxSizes.value);\n    }\n    const currentSizes = pxSizes.value;\n    const currentIndex = type === \"start\" ? index : index + 1;\n    const targetIndex = type === \"start\" ? index + 1 : index;\n    const currentSize = currentSizes[currentIndex];\n    const targetSize = currentSizes[targetIndex];\n    if (currentSize !== 0 && targetSize !== 0) {\n      currentSizes[currentIndex] = 0;\n      currentSizes[targetIndex] += currentSize;\n      cacheCollapsedSize[index] = currentSize;\n    } else {\n      const totalSize = currentSize + targetSize;\n      const targetCacheCollapsedSize = cacheCollapsedSize[index];\n      const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize;\n      currentSizes[targetIndex] = targetCacheCollapsedSize;\n      currentSizes[currentIndex] = currentCacheCollapsedSize;\n    }\n    panels.value.forEach((panel, index2) => {\n      panel.size = currentSizes[index2];\n    });\n  };\n  return {\n    lazyOffset,\n    onMoveStart,\n    onMoving,\n    onMoveEnd,\n    movingIndex,\n    onCollapse\n  };\n}\nexport { useResize };","map":{"version":3,"names":["useResize","panels","containerSize","pxSizes","lazy","ptg2px","ptg","value","getLimitSize","str","defaultLimit","isPct","getPct","isPx","getPx","lazyOffset","ref","movingIndex","cachePxSizes","updatePanelSizes","NOOP","limitSizes","computed","map","item","min","max","watch","mouseup","MouseEvent","bubbles","window","dispatchEvent","onMoveStart","index","confirmed","onMoving","offset","_a","_b","confirmedIndex","i","mergedIndex","numSizes","nextIndex","startMinSize","endMinSize","startMaxSize","endMaxSize","mergedOffset","forEach","panel","index2","size","onMoveEnd","cacheCollapsedSize","onCollapse","type","length","push","currentSizes","currentIndex","targetIndex","currentSize","targetSize","totalSize","targetCacheCollapsedSize","currentCacheCollapsedSize"],"sources":["../../../../../../../packages/components/splitter/src/hooks/useResize.ts"],"sourcesContent":["import { computed, ref, watch } from 'vue'\nimport { getPct, getPx, isPct, isPx } from './useSize'\nimport { NOOP } from '@element-plus/utils'\n\nimport type { ComputedRef, Ref } from 'vue'\nimport type { PanelItemState } from '../type'\n\nexport function useResize(\n  panels: Ref<PanelItemState[]>,\n  containerSize: ComputedRef<number>,\n  pxSizes: ComputedRef<number[]>,\n  lazy: Ref<boolean>\n) {\n  const ptg2px = (ptg: number) => ptg * containerSize.value || 0\n\n  function getLimitSize(\n    str: string | number | undefined,\n    defaultLimit: number\n  ) {\n    if (isPct(str)) {\n      return ptg2px(getPct(str))\n    } else if (isPx(str)) {\n      return getPx(str)\n    }\n    return str ?? defaultLimit\n  }\n\n  const lazyOffset = ref(0)\n  const movingIndex = ref<{\n    index: number\n    confirmed: boolean\n  } | null>(null)\n\n  let cachePxSizes: number[] = []\n  let updatePanelSizes = NOOP\n\n  const limitSizes = computed(() =>\n    panels.value.map((item) => [item.min, item.max])\n  )\n\n  watch(lazy, () => {\n    if (lazyOffset.value) {\n      const mouseup = new MouseEvent('mouseup', { bubbles: true })\n      window.dispatchEvent(mouseup)\n    }\n  })\n\n  const onMoveStart = (index: number) => {\n    lazyOffset.value = 0\n    movingIndex.value = { index, confirmed: false }\n    cachePxSizes = pxSizes.value\n  }\n\n  const onMoving = (index: number, offset: number) => {\n    let confirmedIndex: number | null = null\n\n    // When overlapping, find the nearest draggable index\n    if ((!movingIndex.value || !movingIndex.value.confirmed) && offset !== 0) {\n      if (offset > 0) {\n        confirmedIndex = index\n        movingIndex.value = { index, confirmed: true }\n      } else {\n        for (let i = index; i >= 0; i -= 1) {\n          if (cachePxSizes[i]! > 0) {\n            confirmedIndex = i\n            movingIndex.value = { index: i, confirmed: true }\n            break\n          }\n        }\n      }\n    }\n    const mergedIndex = confirmedIndex ?? movingIndex.value?.index ?? index\n\n    const numSizes = [...cachePxSizes]\n    const nextIndex = mergedIndex + 1\n\n    // Handle the maximum and minimum edge cases\n    const startMinSize = getLimitSize(limitSizes.value[mergedIndex]![0], 0)\n    const endMinSize = getLimitSize(limitSizes.value[nextIndex]![0], 0)\n    const startMaxSize = getLimitSize(\n      limitSizes.value[mergedIndex]![1],\n      containerSize.value || 0\n    )\n    const endMaxSize = getLimitSize(\n      limitSizes.value[nextIndex]![1],\n      containerSize.value || 0\n    )\n\n    let mergedOffset = offset\n\n    if (numSizes[mergedIndex]! + mergedOffset < startMinSize) {\n      mergedOffset = startMinSize - numSizes[mergedIndex]!\n    }\n    if (numSizes[nextIndex]! - mergedOffset < endMinSize) {\n      mergedOffset = numSizes[nextIndex]! - endMinSize\n    }\n    if (numSizes[mergedIndex]! + mergedOffset > startMaxSize) {\n      mergedOffset = startMaxSize - numSizes[mergedIndex]!\n    }\n    if (numSizes[nextIndex]! - mergedOffset > endMaxSize) {\n      mergedOffset = numSizes[nextIndex]! - endMaxSize\n    }\n\n    numSizes[mergedIndex]! += mergedOffset\n    numSizes[nextIndex]! -= mergedOffset\n    lazyOffset.value = mergedOffset\n\n    updatePanelSizes = () => {\n      panels.value.forEach((panel, index) => {\n        panel.size = numSizes[index]\n      })\n      updatePanelSizes = NOOP\n    }\n\n    if (!lazy.value) {\n      updatePanelSizes()\n    }\n  }\n\n  const onMoveEnd = () => {\n    if (lazy.value) {\n      updatePanelSizes()\n    }\n\n    lazyOffset.value = 0\n    movingIndex.value = null\n    cachePxSizes = []\n  }\n\n  const cacheCollapsedSize: number[] = []\n  const onCollapse = (index: number, type: 'start' | 'end') => {\n    if (!cacheCollapsedSize.length) {\n      cacheCollapsedSize.push(...pxSizes.value)\n    }\n\n    const currentSizes = pxSizes.value\n\n    const currentIndex = type === 'start' ? index : index + 1\n    const targetIndex = type === 'start' ? index + 1 : index\n\n    const currentSize = currentSizes[currentIndex]\n    const targetSize = currentSizes[targetIndex]\n\n    if (currentSize !== 0 && targetSize !== 0) {\n      currentSizes[currentIndex] = 0\n      currentSizes[targetIndex]! += currentSize\n      cacheCollapsedSize[index] = currentSize\n    } else {\n      const totalSize = currentSize + targetSize\n\n      const targetCacheCollapsedSize = cacheCollapsedSize[index]\n      const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize\n\n      currentSizes[targetIndex] = targetCacheCollapsedSize\n      currentSizes[currentIndex] = currentCacheCollapsedSize\n    }\n\n    panels.value.forEach((panel, index) => {\n      panel.size = currentSizes[index]\n    })\n  }\n\n  return {\n    lazyOffset,\n    onMoveStart,\n    onMoving,\n    onMoveEnd,\n    movingIndex,\n    onCollapse,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}